{"version":3,"file":"export.cjs.js","sources":["../src/R2Vector.ts","../src/S2Point.ts","../src/S2Metric.ts","../src/S2.ts","../src/S1Angle.ts","../src/Interval.ts","../src/S1Interval.ts","../src/R1Interval.ts","../src/S2LatLng.ts","../src/S2EdgeUtil.ts","../src/S2LatLngRect.ts","../src/S2Cap.ts","../src/MutableInteger.ts","../src/S2CellId.ts","../src/S2Projections.ts","../src/S2Cell.ts","../src/S2CellUnion.ts","../src/S2RegionCoverer.ts","../src/export.ts"],"sourcesContent":["import {S2Point} from \"./S2Point\";\nimport * as decimal from 'decimal.js';\nimport {S2} from \"./S2\";\n\n/**\n * R2Vector represents a vector in the two-dimensional space. It defines the\n * basic geometrical operations for 2D vectors, e.g. cross product, addition,\n * norm, comparison etc.\n *\n */\nexport class R2Vector {\n  private _x: decimal.Decimal;\n  private _y: decimal.Decimal;\n  constructor(_x:number|decimal.Decimal, _y:number|decimal.Decimal) {\n    this._x = new decimal.Decimal(_x) as decimal.Decimal;\n    this._y = new decimal.Decimal(_y) as decimal.Decimal;\n    // this._x = new Decimal(_x) as decimal.Decimal;\n    // this._y = new Decimal(_y) as decimal.Decimal;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n\n  public get(index:number):decimal.Decimal{\n    if (index > 1) {\n      throw new Error(`Index out fo bounds error ${index}`);\n    }\n    return index == 0 ? this._x : this._y;\n  }\n\n  static fromPointFace(p:S2Point, face:number): R2Vector {\n    return p.toR2Vector(face);\n  }\n  public static  add(p1:R2Vector, p2:R2Vector):R2Vector {\n    return new R2Vector(p1._x.plus(p2._x), p1._y.plus(p2._y));\n  }\n\n  public static mul(p:R2Vector, _m:number|decimal.Decimal):R2Vector {\n    const m:decimal.Decimal = new decimal.Decimal(_m) as decimal.Decimal;\n    return new R2Vector(m.times(p._x), m.times(p._y));\n  }\n\n  public norm2():decimal.Decimal {\n    return this.x.pow(2).plus(this.y.pow(2));\n  }\n\n  public static dotProd(p1:R2Vector, p2:R2Vector):decimal.Decimal {\n    return p1.x.times(p2.x).plus(p1.y.times(p2.y));\n  }\n\n  public dotProd(that:R2Vector):decimal.Decimal {\n    return R2Vector.dotProd(this, that);\n  }\n\n  public crossProd(that:R2Vector):decimal.Decimal {\n    return this.x.times(that.y).minus(this.y.times(that.x));\n  }\n\n  public lessThan(vb:R2Vector):boolean {\n    if (this.x.lt(vb.x)) {\n      return true;\n    }\n    if (vb.x.lt(this.x)) {\n      return false;\n    }\n    if (this.y.lt(vb.y)) {\n      return true;\n    }\n    return false;\n  }\n\n//\n// @Override\n// public boolean equals(Object that) {\n//   if (!(that instanceof R2Vector)) {\n//     return false;\n//   }\n//   R2Vector thatPoint = (R2Vector) that;\n//   return this.x == thatPoint.x && this.y == thatPoint.y;\n// }\n\n// /**\n//  * Calcualates hashcode based on stored coordinates. Since we want +0.0 and\n//  * -0.0 to be treated the same, we ignore the sign of the coordinates.\n//  */\n// @Override\n// public int hashCode() {\n//   long value = 17;\n//   value += 37 * value + Double.doubleToLongBits(Math.abs(x));\n//   value += 37 * value + Double.doubleToLongBits(Math.abs(y));\n//   return (int) (value ^ (value >>> 32));\n// }\n//\n\n  public static fromSTVector(stVector: R2Vector):R2Vector{\n    return new R2Vector(\n      R2Vector.singleStTOUV(stVector.x),\n      R2Vector.singleStTOUV(stVector.y)\n    );\n    \n  }\n\n  // from S2Projections.stToUV (QUADRATIC)\n  public static singleStTOUV(_s:number|decimal.Decimal):decimal.Decimal {\n    const s = S2.toDecimal(_s);\n    if (s.gte(0)) {\n      return S2.toDecimal(1)\n              .dividedBy(3)\n              .times(\n                  s.plus(1).pow(2).minus(1)\n              );\n      // return (1 / 3.) * ((1 + s) * (1 + s) - 1);\n    } else {\n      return S2.toDecimal(1)\n          .dividedBy(3)\n          .times(\n              S2.toDecimal(1)\n                  .minus(S2.toDecimal(1).minus(s).pow(2)\n                  )\n          );\n      // return (1 / 3.) * (1 - (1 - s) * (1 - s));\n    }\n\n  }\n  public static singleUVToST(_x:number|decimal.Decimal) {\n    const x = S2.toDecimal(_x);\n    if (x.gte(0)) {\n      return decimal.Decimal.sqrt(x.times(3).plus(1)).minus(1);\n    } else {\n      return S2.toDecimal(1)\n          .minus(\n              decimal.Decimal.sqrt(\n                  S2.toDecimal(1).minus(x.times(3)\n              )\n              )\n          )\n    }\n  }\n\n  /**\n   * To be used only if this vector is representing uv.\n   * @param face\n   * @returns {S2Point}\n   */\n  public toPoint(face:number) {\n    switch (face) {\n      case 0:\n        return new S2Point(1, this.x, this.y);\n      case 1:\n        return new S2Point(this.x.neg(), 1, this.y);\n      case 2:\n        return new S2Point(this.x.neg(), this.y.neg(), 1);\n      case 3:\n        return new S2Point(-1, this.y.neg(), this.x.neg());\n      case 4:\n        return new S2Point(this.y, -1, this.x.neg());\n      default:\n        return new S2Point(this.y, this.x, -1);\n    }\n  }\n\n  public toSt(which) {\n    return which == 0?R2Vector.singleUVToST(this.x): R2Vector.singleUVToST(this.y);\n  }\n  public toString():string {\n    return \"(\" + this.x.toString() + \", \" + this.y.toString() + \")\";\n  }\n\n}\n","/*\n * Copyright 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {R2Vector} from \"./R2Vector\";\nimport * as decimal from 'decimal.js';\nimport {S2} from \"./S2\";\n\n///re\n/**\n * An S2Point represents a point on the unit sphere as a 3D vector. Usually\n * points are normalized to be unit length, but some methods do not require\n * this.\n *\n */\nexport class S2Point {\n  public x: decimal.Decimal;\n  public y: decimal.Decimal;\n  public z: decimal.Decimal;\n  constructor(x:decimal.Decimal|number|string, y:decimal.Decimal|number|string, z:decimal.Decimal|number|string) {\n    this.x = new decimal.Decimal(x)  as decimal.Decimal;\n    this.y = new decimal.Decimal(y)  as decimal.Decimal ;\n    this.z = new decimal.Decimal(z)  as decimal.Decimal;\n    // this.y = typeof(y) === 'number'?new decimal.Decimal(y):y as decimal.Decimal;\n    // this.z = typeof(z) === 'number'?new decimal.Decimal(z):z as decimal.Decimal;\n  }\n\n  static minus(p1:S2Point, p2:S2Point) {\n    return S2Point.sub(p1, p2);\n  }\n\n  static neg(p) {\n    return new S2Point(p.x.negated(), p.y.negated(), p.z.negated());\n  }\n\n  public norm2():decimal.Decimal {\n    return this.x.pow(2).plus(this.y.pow(2)).plus(this.z.pow(2));\n  }\n\n  public norm():decimal.Decimal {\n    return this.norm2().sqrt();\n  }\n\n\n  static crossProd(p1:S2Point, p2:S2Point):S2Point {\n\n    return new S2Point(\n        p1.y.times(p2.z).minus(p1.z.times(p2.y)),\n        p1.z.times(p2.x).minus(p1.x.times(p2.z)),\n        // p1.z * p2.x - p1.x * p2.z,\n        p1.x.times(p2.y).minus(p1.y.times(p2.x))\n        // p1.x * p2.y - p1.y * p2.x\n    );\n  }\n\n  static add(p1, p2):S2Point {\n    return new S2Point(p1.x.add(p2.x), p1.y.add(p2.y), p1.z.add(p2.z));\n  }\n\n  static sub(p1, p2):S2Point {\n    return new S2Point(p1.x.sub(p2.x), p1.y.sub(p2.y), p1.z .sub(p2.z));\n  }\n\n  public dotProd(that:S2Point):decimal.Decimal {\n    return this.x.times(that.x).plus(this.y.times(that.y)).plus(this.z.times(that.z));\n  }\n\n  public static mul(p, m:decimal.Decimal|number):S2Point {\n    let mD = new decimal.Decimal(m) as decimal.Decimal;\n    return new S2Point(mD.times(p.x), mD.times(p.y) , mD.times(p.z));\n  }\n\n  public static div(p:S2Point, m:number):S2Point {\n    return new S2Point(p.x.div(m), p.y.div(m), p.z.div(m));\n  }\n\n  /** return a vector orthogonal to this one */\n  public ortho():S2Point {\n    let k = this.largestAbsComponent();\n    let temp;\n    if (k == 1) {\n      temp = new S2Point(1,0,0);\n    } else if (k == 2) {\n      temp = new S2Point(0,1,0);\n    } else {\n      temp = new S2Point(0,0,1);\n    }\n    return S2Point.normalize(S2Point.crossProd(this, temp));\n  }\n\n  /** Return the index of the largest component fabs */\n  public largestAbsComponent():number {\n    let temp = S2Point.fabs(this);\n    if (temp.x.greaterThan(temp.y)) {\n      if (temp.x.greaterThan(temp.z)) {\n        return 0;\n      } else {\n        return 2;\n      }\n    } else {\n      if (temp.y.greaterThan(temp.z)) {\n        return 1;\n      } else {\n        return 2;\n      }\n    }\n  }\n\n  public static fabs(p:S2Point):S2Point {\n    return new S2Point(p.x.abs(), p.y.abs(), p.z.abs());\n  }\n\n  public static normalize(p:S2Point) {\n    let norm = p.norm();\n\n    if (!norm.eq(0)) {\n      norm = S2.toDecimal(1).dividedBy(norm);\n    }\n    return S2Point.mul(p, norm);\n  }\n\n  axis(axis:number):decimal.Decimal {\n    return (axis == 0) ? this.x : (axis == 1) ? this.y : this.z;\n  }\n\n  /** Return the angle between two vectors in radians */\n  public angle(va) {\n\n    return decimal.Decimal.atan2(S2Point.crossProd(this, va).norm(), this.dotProd(va)\n    );\n  }\n\n  /**\n   * Compare two vectors, return true if all their components are within a\n   * difference of margin.\n   */\n  aequal(that:S2Point, margin:number):boolean {\n    return this.x.minus(that.x).abs().lessThan(margin) &&\n            this.y.minus(that.y).abs().lessThan(margin) &&\n            this.z.minus(that.z).abs().lessThan(margin);\n  }\n\n  equals(that:S2Point):boolean {\n    if (!(that instanceof S2Point)) {\n      return false;\n    }\n    return this.x.eq(that.x) && this.y.eq(that.y) && this.z.eq(that.z);\n  }\n\n  public lessThan(vb:S2Point):boolean {\n    if (this.x.lt(vb.x)) {\n      return true;\n    }\n    if (vb.x.lt(this.x)) {\n      return false;\n    }\n    if (this.y.lt(vb.y)) {\n      return true;\n    }\n    if (vb.y.lt(this.y)) {\n      return false;\n    }\n    if (this.z.lt(vb.z)) {\n      return true;\n    }\n    return false;\n  }\n\n  public compareTo(other:S2Point):number {\n    return (this.lessThan(other) ? -1 : (this.equals(other) ? 0 : 1));\n  }\n\n\n  toFace():number {\n    let face = this.largestAbsComponent();\n    if (this.axis(face).lt(0)) {\n      face += 3;\n    }\n    return face;\n  }\n\n  toR2Vector(face:number = this.toFace()):R2Vector {\n    let u;\n    let v;\n    switch (face) {\n      case 0:\n        u = this.y.div(this.x);\n        v = this.z.div(this.x);\n        break;\n      case 1:\n        u = this.x.neg().div(this.y);\n        v = this.z.div(this.y);\n        break;\n      case 2:\n        u = this.x.neg().div(this.z);\n        v = this.y.neg().div(this.z);\n        break;\n      case 3:\n        u = this.z.div(this.x);\n        v = this.y.div(this.x);\n        break;\n      case 4:\n        u = this.z.div(this.y);\n        v = this.x.neg().div(this.y);\n        break;\n      case 5:\n        u = this.y.neg().div(this.z);\n        v = this.x.neg().div(this.z);\n        break;\n      default:\n        throw new Error('Invalid face');\n    }\n    return new R2Vector(u, v);\n  }\n\n\n  toString():string {\n    return `Point(${this.x.toNumber()}, ${this.y.toNumber()}, ${this.z.toNumber()})`;\n  }\n}\n","import {S2} from \"./S2\";\nimport * as decimal from 'decimal.js';\n\n/**\n * Defines an area or a length cell metric.\n */\nexport class S2Metric {\n    private _dim:number;\n    private _deriv:decimal.Decimal;\n\n    /**\n     * Defines a cell metric of the given dimension (1 == length, 2 == area).\n     */\n    public constructor(_dim:number|decimal.Decimal, _deriv:number|decimal.Decimal) {\n        this._dim = S2.toDecimal(_dim).toNumber();\n        this._deriv = S2.toDecimal(_deriv);\n\n    }\n\n    deriv() {\n        return this._deriv;\n    }\n\n    dim() {\n        return this._dim;\n    }\n\n    /** Return the value of a metric for cells at the given level. */\n    public getValue(level:number):number {\n        let scaleFactor = this.dim() * (1 - level);\n        return this.deriv().times(Math.pow(2, scaleFactor)).toNumber();\n    }\n\n    /**\n     * Return the level at which the metric has approximately the given value.\n     * For example, S2::kAvgEdge.GetClosestLevel(0.1) returns the level at which\n     * the average cell edge length is approximately 0.1. The return value is\n     * always a valid level.\n     */\n    public getClosestLevel(/*double*/value:number):number {\n        return this.getMinLevel(S2.M_SQRT2 * value);\n    }\n\n    /**\n     * Return the minimum level such that the metric is at most the given value,\n     * or S2CellId::kMaxLevel if there is no such level. For example,\n     * S2::kMaxDiag.GetMinLevel(0.1) returns the minimum level such that all\n     * cell diagonal lengths are 0.1 or smaller. The return value is always a\n     * valid level.\n     */\n    public getMinLevel(value:number /*double*/):number /*int*/ {\n        if (value <= 0) {\n            return S2.MAX_LEVEL;\n        }\n\n        // This code is equivalent to computing a floating-point \"level\"\n        // value and rounding up.\n        let exponent = S2.exp(value / ((1 << this.dim()) * this.deriv().toNumber()));\n        let level = Math.max(0,\n            Math.min(S2.MAX_LEVEL, -((exponent - 1) >> (this.dim() - 1))));\n        // assert (level == S2CellId.MAX_LEVEL || getValue(level) <= value);\n        // assert (level == 0 || getValue(level - 1) > value);\n        return level;\n    }\n\n    /**\n     * Return the maximum level such that the metric is at least the given\n     * value, or zero if there is no such level. For example,\n     * S2.kMinWidth.GetMaxLevel(0.1) returns the maximum level such that all\n     * cells have a minimum width of 0.1 or larger. The return value is always a\n     * valid level.\n     */\n    public getMaxLevel(_value:number|decimal.Decimal /*double*/):number {\n        const value = S2.toDecimal(_value).toNumber();\n        if (value <= 0) {\n            return S2.MAX_LEVEL;\n        }\n\n        // This code is equivalent to computing a floating-point \"level\"\n        // value and rounding down.\n        let exponent = S2.exp((1 << this.dim()) * this.deriv().toNumber() / value);\n        let level = Math.max(0,\n            Math.min(S2.MAX_LEVEL, ((exponent - 1) >> (this.dim() - 1))));\n        // assert (level == 0 || getValue(level) >= value);\n        // assert (level == S2CellId.MAX_LEVEL || getValue(level + 1) < value);\n        return level;\n    }\n}\n","import {S2Point} from \"./S2Point\";\nimport * as decimal from 'decimal.js';\nimport {S2Metric} from \"./S2Metric\";\nimport Long from 'long';\n\nexport class S2 {\n\n  public static M_PI = Math.PI;\n  public static M_1_PI = 1.0 / Math.PI;\n  public static M_PI_2 = Math.PI / 2.0;\n  public static M_PI_4 = Math.PI / 4.0;\n  public static M_SQRT2 = Math.sqrt(2);\n  public static M_E = Math.E;\n  // the axis directions are reversed).\n  public static SWAP_MASK = 0x01;\n  public static INVERT_MASK = 0x02;\n\n  // Number of bits in the mantissa of a double.\n  private static EXPONENT_SHIFT = 52;\n  // Mask to extract the exponent from a double.\n  private static EXPONENT_MASK = Long.fromString('0x7ff0000000000000', true, 16);\n  /** Mapping from cell orientation + Hilbert traversal to IJ-index. */\n  public static POS_TO_ORIENTATION = [S2.SWAP_MASK, 0, 0, S2.INVERT_MASK + S2.SWAP_MASK];\n\n  public static POS_TO_IJ = [\n    // 0 1 2 3\n    [0, 1, 3, 2], // canonical order: (0,0), (0,1), (1,1), (1,0)\n    [0, 2, 3, 1], // axes swapped: (0,0), (1,0), (1,1), (0,1)\n    [3, 2, 0, 1], // bits inverted: (1,1), (1,0), (0,0), (0,1)\n    [3, 1, 0, 2], // swapped & inverted: (1,1), (0,1), (0,0), (1,0)\n  ];\n  static MAX_LEVEL = 30;\n\n  public static IEEEremainder(_f1:number|decimal.Decimal, _f2:number|decimal.Decimal) {\n    const f1 = S2.toDecimal(_f1);\n    const f2 = S2.toDecimal(_f2);\n    let r = f1.mod(f2);\n\n    if (r.isNaN() || r.eq(f2) || r.lessThanOrEqualTo(f2.abs().dividedBy(2))) {\n      return r;\n    } else {\n      return (f1.gte(0) ? S2.toDecimal(1) : S2.toDecimal(-1)).times(r.minus(f2));\n    }\n  }\n\n  /**\n   * Return true if the given point is approximately unit length (this is mainly\n   * useful for assertions).\n   */\n  public static isUnitLength(p:S2Point):boolean {\n    return p.norm2().minus(1).abs().lte(1e-15);\n  }\n\n  /**\n   * If v is non-zero, return an integer {@code exp} such that\n   * {@code (0.5 <= |v|*2^(-exp) < 1)}. If v is zero, return 0.\n   *\n   * <p>Note that this arguably a bad definition of exponent because it makes\n   * {@code exp(9) == 4}. In decimal this would be like saying that the\n   * exponent of 1234 is 4, when in scientific 'exponent' notation 1234 is\n   * {@code 1.234 x 10^3}.\n   *\n   * TODO(dbeaumont): Replace this with \"DoubleUtils.getExponent(v) - 1\" ?\n   */\n  static exp(v:number /*double*/):number {\n    if (v == 0) {\n      return 0;\n    }\n    // IT should always be ((int)log(2,v))+1;\n    const start = Math.floor(Math.log(v)/Math.log(2));\n    for(let i= start; i<start+10; i++) {\n      const curVal = Math.abs(v) * Math.pow(2,-i);\n      if (curVal >= 0.5 && curVal < 1 ) {\n        return i;\n      }\n    }\n    throw new Error('method not written yet');\n    // return (int)((S2.EXPONENT_MASK & bits) >> S2.EXPONENT_SHIFT) - 1022;\n  }\n\n  /**\n   * Return a vector \"c\" that is orthogonal to the given unit-length vectors \"a\"\n   * and \"b\". This function is similar to a.CrossProd(b) except that it does a\n   * better job of ensuring orthogonality when \"a\" is nearly parallel to \"b\",\n   * and it returns a non-zero result even when a == b or a == -b.\n   *\n   *  It satisfies the following properties (RCP == RobustCrossProd):\n   *\n   *  (1) RCP(a,b) != 0 for all a, b (2) RCP(b,a) == -RCP(a,b) unless a == b or\n   * a == -b (3) RCP(-a,b) == -RCP(a,b) unless a == b or a == -b (4) RCP(a,-b)\n   * == -RCP(a,b) unless a == b or a == -b\n   */\n  static robustCrossProd(a:S2Point, b:S2Point):S2Point {\n    // The direction of a.CrossProd(b) becomes unstable as (a + b) or (a - b)\n    // approaches zero. This leads to situations where a.CrossProd(b) is not\n    // very orthogonal to \"a\" and/or \"b\". We could fix this using Gram-Schmidt,\n    // but we also want b.RobustCrossProd(a) == -b.RobustCrossProd(a).\n    //\n    // The easiest fix is to just compute the cross product of (b+a) and (b-a).\n    // Given that \"a\" and \"b\" are unit-length, this has good orthogonality to\n    // \"a\" and \"b\" even if they differ only in the lowest bit of one component.\n\n    // assert (isUnitLength(a) && isUnitLength(b));\n    let x = S2Point.crossProd(S2Point.add(b, a), S2Point.sub(b, a));\n    if (!x.equals(new S2Point(0, 0, 0))) {\n      return x;\n    }\n    // The only result that makes sense mathematically is to return zero, but\n    // we find it more convenient to return an arbitrary orthogonal vector.\n    return a.ortho();\n  }\n\n  /**\n   * Return the area of triangle ABC. The method used is about twice as\n   * expensive as Girard's formula, but it is numerically stable for both large\n   * and very small triangles. The points do not need to be normalized. The area\n   * is always positive.\n   *\n   *  The triangle area is undefined if it contains two antipodal points, and\n   * becomes numerically unstable as the length of any edge approaches 180\n   * degrees.\n   */\n  static area(a:S2Point, b:S2Point, c:S2Point):decimal.Decimal {\n    // This method is based on l'Huilier's theorem,\n    //\n    // tan(E/4) = sqrt(tan(s/2) tan((s-a)/2) tan((s-b)/2) tan((s-c)/2))\n    //\n    // where E is the spherical excess of the triangle (i.e. its area),\n    // a, b, c, are the side lengths, and\n    // s is the semiperimeter (a + b + c) / 2 .\n    //\n    // The only significant source of error using l'Huilier's method is the\n    // cancellation error of the terms (s-a), (s-b), (s-c). This leads to a\n    // *relative* error of about 1e-16 * s / min(s-a, s-b, s-c). This compares\n    // to a relative error of about 1e-15 / E using Girard's formula, where E is\n    // the true area of the triangle. Girard's formula can be even worse than\n    // this for very small triangles, e.g. a triangle with a true area of 1e-30\n    // might evaluate to 1e-5.\n    //\n    // So, we prefer l'Huilier's formula unless dmin < s * (0.1 * E), where\n    // dmin = min(s-a, s-b, s-c). This basically includes all triangles\n    // except for extremely long and skinny ones.\n    //\n    // Since we don't know E, we would like a conservative upper bound on\n    // the triangle area in terms of s and dmin. It's possible to show that\n    // E <= k1 * s * sqrt(s * dmin), where k1 = 2*sqrt(3)/Pi (about 1).\n    // Using this, it's easy to show that we should always use l'Huilier's\n    // method if dmin >= k2 * s^5, where k2 is about 1e-2. Furthermore,\n    // if dmin < k2 * s^5, the triangle area is at most k3 * s^4, where\n    // k3 is about 0.1. Since the best case error using Girard's formula\n    // is about 1e-15, this means that we shouldn't even consider it unless\n    // s >= 3e-4 or so.\n\n    // We use volatile doubles to force the compiler to truncate all of these\n    // quantities to 64 bits. Otherwise it may compute a value of dmin > 0\n    // simply because it chose to spill one of the intermediate values to\n    // memory but not one of the others.\n    const sa = b.angle(c);\n    const sb = c.angle(a);\n    const sc = a.angle(b);\n    const s = sa.plus(sb).plus(sc).times(0.5);\n    // 0.5 * (sa + sb + sc);\n    if (s.gte(3e-4)) {\n      // Consider whether Girard's formula might be more accurate.\n      const s2 = s.pow(2);\n      const dmin = s.minus(\n          decimal.Decimal.max(\n              sa,\n              sb,\n              sc\n          )\n      );\n      if (dmin.lt(s2.pow(2).times(s).times(1e-2))) {\n        // This triangle is skinny enough to consider Girard's formula.\n        const area = S2.girardArea(a, b, c);\n        if (dmin.lt(s.times(area.times(0.1)))) {\n          return area;\n        }\n      }\n    }\n    // Use l'Huilier's formula.\n    return S2.toDecimal(4)\n        .times(\n            decimal.Decimal.atan(\n                decimal.Decimal.sqrt(\n                    decimal.Decimal.max(\n                        0.0,\n                        decimal.Decimal.tan(s.times(0.5))\n                            .times(decimal.Decimal.tan(s.minus(sa).times(0.5)))\n                            .times(decimal.Decimal.tan(s.minus(sb).times(0.5)))\n                            .times(decimal.Decimal.tan(s.minus(sc).times(0.5)))\n                    )\n                )\n            )\n        )\n  }\n\n\n  /**\n   * Return the area of the triangle computed using Girard's formula. This is\n   * slightly faster than the Area() method above is not accurate for very small\n   * triangles.\n   */\n  static girardArea(a:S2Point, b:S2Point, c:S2Point):decimal.Decimal {\n    // This is equivalent to the usual Girard's formula but is slightly\n    // more accurate, faster to compute, and handles a == b == c without\n    // a special case.\n\n    const ab = S2Point.crossProd(a, b);\n    const bc = S2Point.crossProd(b, c);\n    const ac = S2Point.crossProd(a, c);\n    return decimal.Decimal.max(\n        0,\n        ab.angle(ac)\n            .minus(ab.angle(bc))\n            .plus(bc.angle(ac))\n    );\n  }\n\n  public static toDecimal(value:number|decimal.Decimal|string):decimal.Decimal {\n    if (typeof(value) === 'number' || typeof(value) === 'string') {\n      return new decimal.Decimal(value) as decimal.Decimal\n    }\n    return value as decimal.Decimal;\n  }\n\n\n  /**\n   * Return true if the points A, B, C are strictly counterclockwise. Return\n   * false if the points are clockwise or colinear (i.e. if they are all\n   * contained on some great circle).\n   *\n   *  Due to numerical errors, situations may arise that are mathematically\n   * impossible, e.g. ABC may be considered strictly CCW while BCA is not.\n   * However, the implementation guarantees the following:\n   *\n   *  If SimpleCCW(a,b,c), then !SimpleCCW(c,b,a) for all a,b,c.\n   *\n   * In other words, ABC and CBA are guaranteed not to be both CCW\n   */\n  public static simpleCCW(a:S2Point, b:S2Point, c:S2Point):boolean {\n    // We compute the signed volume of the parallelepiped ABC. The usual\n    // formula for this is (AxB).C, but we compute it here using (CxA).B\n    // in order to ensure that ABC and CBA are not both CCW. This follows\n    // from the following identities (which are true numerically, not just\n    // mathematically):\n    //\n    // (1) x.CrossProd(y) == -(y.CrossProd(x))\n    // (2) (-x).DotProd(y) == -(x.DotProd(y))\n\n    return S2Point.crossProd(c, a).dotProd(b).gt(0);\n  }\n\n  /**\n   *\n   * Return true if edge AB crosses CD at a point that is interior to both\n   * edges. Properties:\n   *\n   *  (1) SimpleCrossing(b,a,c,d) == SimpleCrossing(a,b,c,d) (2)\n   * SimpleCrossing(c,d,a,b) == SimpleCrossing(a,b,c,d)\n   */\n  public static  simpleCrossing(a:S2Point, b:S2Point, c:S2Point, d:S2Point):boolean {\n    // We compute SimpleCCW() for triangles ACB, CBD, BDA, and DAC. All\n    // of these triangles need to have the same orientation (CW or CCW)\n    // for an intersection to exist. Note that this is slightly more\n    // restrictive than the corresponding definition for planar edges,\n    // since we need to exclude pairs of line segments that would\n    // otherwise \"intersect\" by crossing two antipodal points.\n\n    const ab = S2Point.crossProd(a, b);\n    const cd = S2Point.crossProd(c, d);\n    const acb = ab.dotProd(c).neg();\n    const cbd = cd.dotProd(b).neg();\n    const bda = ab.dotProd(d);\n    const dac = cd.dotProd(a);\n\n    return (acb.times(cbd).gt(0)) && (cbd.times(bda).gt(0)) && (bda.times(dac).gt(0));\n  }\n\n  static Metric = S2Metric\n}\n\nexport { S2Metric };\n","import {S2Point} from \"./S2Point\";\nimport * as decimal from 'decimal.js';\nimport {S2} from \"./S2\";\nexport class S1Angle {\n\n  public radians: decimal.Decimal;\n  constructor(radians:number|decimal.Decimal) {\n    this.radians = new decimal.Decimal(radians);\n  }\n\n\n  public degrees() {\n    return S2.toDecimal(this.radians).times((180 / Math.PI));\n  }\n\n  //\n  // public long e5() {\n  //   return Math.round(degrees() * 1e5);\n  // }\n  //\n  // public long e6() {\n  //   return Math.round(degrees() * 1e6);\n  // }\n  //\n  // public long e7() {\n  //   return Math.round(degrees() * 1e7);\n  // }\n\n  /**\n   * Return the angle between two points, which is also equal to the distance\n   * between these points on the unit sphere. The points do not need to be\n   * normalized.\n   */\n  static fromPoints(x:S2Point, y:S2Point) {\n    return new S1Angle(x.angle(y));\n  }\n\n  public lessThan(that:S1Angle):boolean {\n    return this.radians.lt(that.radians);\n  }\n\n  public greaterThan(that:S1Angle):boolean {\n    return this.radians .gt(that.radians);\n  }\n\n  public lessOrEquals(that:S1Angle):boolean {\n    return this.radians .lte(that.radians);\n  }\n\n  public greaterOrEquals(that:S1Angle):boolean {\n    return this.radians .gte(that.radians);\n  }\n\n  public static max(left:S1Angle, right:S1Angle):S1Angle {\n    return right.greaterThan(left) ? right : left;\n  }\n\n  public static min(left:S1Angle, right:S1Angle):S1Angle {\n    return right.greaterThan(left) ? left : right;\n  }\n\n  public static degrees(degrees:number|decimal.Decimal):S1Angle {\n    let d = new decimal.Decimal(degrees);\n    return new S1Angle(d.times(Math.PI/180));\n  }\n\n//\n// public static S1Angle e5(long e5) {\n//   return degrees(e5 * 1e-5);\n// }\n//\n// public static S1Angle e6(long e6) {\n//   // Multiplying by 1e-6 isn't quite as accurate as dividing by 1e6,\n//   // but it's about 10 times faster and more than accurate enough.\n//   return degrees(e6 * 1e-6);\n// }\n//\n// public static S1Angle e7(long e7) {\n//   return degrees(e7 * 1e-7);\n// }\n\n  /**\n   * Writes the angle in degrees with a \"d\" suffix, e.g. \"17.3745d\". By default\n   * 6 digits are printed; this can be changed using setprecision(). Up to 17\n   * digits are required to distinguish one angle from another.\n   */\n  public toString():string {\n    return this.degrees() + \"d\";\n  }\n\n  public compareTo(that:S1Angle):number {\n    return this.radians < that.radians ? -1 : this.radians > that.radians ? 1 : 0;\n  }\n}\n","import {S2} from \"./S2\";\nimport * as decimal from 'decimal.js';\nexport abstract class Interval {\n  public lo:decimal.Decimal;\n  public hi:decimal.Decimal;\n\n  constructor(lo:number|decimal.Decimal, hi:number|decimal.Decimal) {\n    this.lo = S2.toDecimal(lo);\n    this.hi = S2.toDecimal(hi);\n  }\n\n  /** Return true if the interval is empty, i.e. it contains no points. */\n\n  public abstract isEmpty():boolean;\n\n  /**\n   * Return the center of the interval. For empty intervals, the result is\n   * arbitrary.\n   */\n  public abstract getCenter():decimal.Decimal;\n\n  /**\n   * Return the length of the interval. The length of an empty interval is\n   * negative.\n   */\n  public abstract getLength():decimal.Decimal;\n\n  public abstract contains(p:number|decimal.Decimal):boolean;\n\n  public abstract interiorContains(p:number|decimal.Decimal):boolean;\n\n  public  toString():string {\n    return \"[\" + this.lo.toString() + \", \" + this.hi.toString() + \"]\";\n  }\n\n\n  /**\n   * Return true if two intervals contains the same set of points.\n   */\n  public equals(that:any):boolean {\n    if (typeof(that) === typeof(this)) {\n      return this.lo .eq(that.lo) && this.hi.eq(that.hi);\n    }\n    return false;\n  }\n\n\n}\n","import {Interval} from \"./Interval\";\nimport {S2} from \"./S2\";\nimport * as decimal from 'decimal.js';\nexport class S1Interval extends Interval {\n\n  constructor(lo:number|decimal.Decimal, hi:number|decimal.Decimal, checked:boolean = false) {\n    super(lo, hi);\n    if (!checked) {\n      if (this.lo.eq(-S2.M_PI) && !this.hi.eq(S2.M_PI)) {\n        this.lo = S2.toDecimal(S2.M_PI);\n      }\n      if (this.hi.eq(-S2.M_PI) && !this.lo.eq(S2.M_PI)) {\n        this.hi = S2.toDecimal(S2.M_PI);\n      }\n    }\n  }\n\n  /**\n   * An interval is valid if neither bound exceeds Pi in absolute value, and the\n   * value -Pi appears only in the Empty() and Full() intervals.\n   */\n  isValid():boolean {\n    return this.lo.abs().lte(S2.M_PI) && this.hi.abs().lte(S2.M_PI)\n        && !(this.lo.eq(-S2.M_PI) && !this.hi.eq(S2.M_PI))\n        && !(this.hi.eq(-S2.M_PI) && !this.lo.eq(S2.M_PI));\n    // return (Math.abs(this.lo) <= S2.M_PI && Math.abs(this.hi) <= S2.M_PI\n    // && !(this.lo == -S2.M_PI && this.hi != S2.M_PI) && !(this.hi == -S2.M_PI && this.lo != S2.M_PI));\n  }\n\n  /** Return true if the interval contains all points on the unit circle. */\n  isFull() {\n    // console.log(this.hi.minus(this.lo).eq(2 * S2.M_PI));\n    return this.hi.minus(this.lo).eq(2 * S2.M_PI)\n  }\n\n\n  /** Return true if the interval is empty, i.e. it contains no points. */\n  public  isEmpty() {\n    return this.lo.minus(this.hi).eq(2 * S2.M_PI);\n  }\n\n\n  /* Return true if this.lo > this.hi. (This is true for empty intervals.) */\n  public isInverted():boolean {\n    return this.lo.gt(this.hi);\n  }\n\n\n  /**\n   * Return the midpoint of the interval. For full and empty intervals, the\n   * result is arbitrary.\n   */\n  public getCenter():decimal.Decimal {\n    let center = this.lo.plus(this.hi).dividedBy(2);\n    // let center = 0.5 * (this.lo + this.hi);\n    if (!this.isInverted()) {\n      return center;\n    }\n    // Return the center in the range (-Pi, Pi].\n    return (center.lte(0)) ? (center.plus(S2.M_PI)) : (center.minus(S2.M_PI));\n  }\n\n\n  /**\n   * Return the length of the interval. The length of an empty interval is\n   * negative.\n   */\n  public getLength():decimal.Decimal {\n    let length = this.hi.minus(this.lo);\n    if (length.gte(0)) {\n      return length;\n    }\n    length = length.plus(2 * S2.M_PI);\n    // Empty intervals have a negative length.\n    return (length.gt(0)) ? length : S2.toDecimal(-1);\n  }\n\n  /**\n   * Return the complement of the interior of the interval. An interval and its\n   * complement have the same boundary but do not share any interior values. The\n   * complement operator is not a bijection, since the complement of a singleton\n   * interval (containing a single value) is the same as the complement of an\n   * empty interval.\n   */\n  public complement():S1Interval {\n    if (this.lo.eq(this.hi)) {\n      return S1Interval.full(); // Singleton.\n    }\n    return new S1Interval(this.hi, this.lo, true); // Handles\n    // empty and\n    // full.\n  }\n\n  /** Return true if the interval (which is closed) contains the point 'p'. */\n  public contains(_p:number|decimal.Decimal):boolean {\n    let p = S2.toDecimal(_p);\n    // Works for empty, full, and singleton intervals.\n    // assert (Math.abs(p) <= S2.M_PI);\n    if (p.eq(-S2.M_PI)) {\n      p = S2.toDecimal(S2.M_PI);\n    }\n    return this.fastContains(p);\n  }\n\n  /**\n   * Return true if the interval (which is closed) contains the point 'p'. Skips\n   * the normalization of 'p' from -Pi to Pi.\n   *\n   */\n  public fastContains(_p:number|decimal.Decimal):boolean {\n    const p = S2.toDecimal(_p);\n    if (this.isInverted()) {\n      return (p.gte(this.lo) || p.lte(this.hi)) && !this.isEmpty();\n    } else {\n      return p.gte(this.lo) && p.lte(this.hi);\n    }\n  }\n\n  /** Return true if the interior of the interval contains the point 'p'. */\n  public interiorContains(_p:number|decimal.Decimal):boolean {\n    // Works for empty, full, and singleton intervals.\n    // assert (Math.abs(p) <= S2.M_PI);\n    let p = S2.toDecimal(_p);\n    if (p.eq(-S2.M_PI)) {\n      p = S2.toDecimal(S2.M_PI);\n    }\n\n    if (this.isInverted()) {\n      return p.gt(this.lo) || p.lt(this.hi);\n    } else {\n      return (p.gt(this.lo) && p.lt(this.hi)) || this.isFull();\n    }\n  }\n\n  /**\n   * Return true if the interval contains the given interval 'y'. Works for\n   * empty, full, and singleton intervals.\n   */\n  public containsI(y:S1Interval):boolean {\n    // It might be helpful to compare the structure of these tests to\n    // the simpler Contains(number) method above.\n\n    if (this.isInverted()) {\n      if (y.isInverted()) {\n        return y.lo.gte(this.lo) && y.hi.lte(this.hi);\n      }\n      return (y.lo.gte(this.lo) || y.hi.lte(this.hi)) && !this.isEmpty();\n    } else {\n      if (y.isInverted()) {\n        return this.isFull() || y.isEmpty();\n      }\n      return y.lo.gte(this.lo) && y.hi.lte(this.hi);\n    }\n  }\n\n  /**\n   * Returns true if the interior of this interval contains the entire interval\n   * 'y'. Note that x.InteriorContains(x) is true only when x is the empty or\n   * full interval, and x.InteriorContains(S1Interval(p,p)) is equivalent to\n   * x.InteriorContains(p).\n   */\n  public interiorContainsI(y:S1Interval):boolean {\n    if (this.isInverted()) {\n      if (!y.isInverted()) {\n        return this.lo.gt(this.lo) || y.hi.lt(this.hi);\n      }\n      return (y.lo.gt(this.lo) && y.hi.lt(this.hi)) || y.isEmpty();\n    } else {\n      if (y.isInverted()) {\n        return this.isFull() || y.isEmpty();\n      }\n      return (y.lo.gt(this.lo) && y.hi.lt(this.hi)) || this.isFull();\n    }\n  }\n\n  /**\n   * Return true if the two intervals contain any points in common. Note that\n   * the point +/-Pi has two representations, so the intervals [-Pi,-3] and\n   * [2,Pi] intersect, for example.\n   */\n  public intersects(y:S1Interval):boolean {\n    if (this.isEmpty() || y.isEmpty()) {\n      return false;\n    }\n    if (this.isInverted()) {\n      // Every non-empty inverted interval contains Pi.\n      return y.isInverted() || y.lo.lte(this.hi) || y.hi.gte(this.lo);\n    } else {\n      if (y.isInverted()) {\n        return y.lo.lte(this.hi) || y.hi.gte(this.lo);\n      }\n      return y.lo.lte(this.hi) && y.hi.gte(this.lo);\n    }\n  }\n\n  /**\n   * Return true if the interior of this interval contains any point of the\n   * interval 'y' (including its boundary). Works for empty, full, and singleton\n   * intervals.\n   */\n  public interiorIntersects(y:S1Interval):boolean {\n    if (this.isEmpty() || y.isEmpty() || this.lo.eq(this.hi)) {\n      return false;\n    }\n    if (this.isInverted()) {\n      return y.isInverted() || y.lo.lt(this.hi) || y.hi.gt(this.lo);\n    } else {\n      if (y.isInverted()) {\n        return y.lo.lt(this.hi) || y.hi.gt(this.lo);\n      }\n      return (y.lo.lt(this.hi) && y.hi.gt(this.lo)) || this.isFull();\n    }\n  }\n\n  /**\n   * Expand the interval by the minimum amount necessary so that it contains the\n   * given point \"p\" (an angle in the range [-Pi, Pi]).\n   */\n  public addPoint(_p:number|decimal.Decimal):S1Interval {\n    let p = S2.toDecimal(_p);\n    // assert (Math.abs(p) <= S2.M_PI);\n    if (p.eq(-S2.M_PI)) {\n      p = S2.toDecimal(S2.M_PI);\n    }\n\n    if (this.fastContains(p)) {\n      return new S1Interval(this.lo, this.hi);\n    }\n\n    if (this.isEmpty()) {\n      return S1Interval.fromPoint(p);\n    } else {\n      // Compute distance from p to each endpoint.\n      let dlo = S1Interval.positiveDistance(p, this.lo);\n      let dhi = S1Interval.positiveDistance(this.hi, p);\n      if (dlo.lt(dhi)) {\n        return new S1Interval(p, this.hi);\n      } else {\n        return new S1Interval(this.lo, p);\n      }\n      // Adding a point can never turn a non-full interval into a full one.\n    }\n  }\n\n  /**\n   * Return an interval that contains all points within a distance \"radius\" of\n   * a point in this interval. Note that the expansion of an empty interval is\n   * always empty. The radius must be non-negative.\n   */\n  public  expanded(_radius:number|decimal.Decimal):S1Interval {\n    const radius = S2.toDecimal(_radius);\n    // assert (radius >= 0);\n    if (this.isEmpty()) {\n      return this;\n    }\n\n    // Check whether this interval will be full after expansion, allowing\n    // for a 1-bit rounding error when computing each endpoint.\n    if (this.getLength().plus(radius.times(2)).gte(2*S2.M_PI-1e-15)) {\n      return S1Interval.full();\n    }\n\n    // NOTE(dbeaumont): Should this remainder be 2 * M_PI or just M_PI ??\n    let lo = S2.IEEEremainder(this.lo.minus(radius), 2 * S2.M_PI);\n    let hi = S2.IEEEremainder(this.hi.plus(radius), 2 * S2.M_PI);\n    if (lo.eq(-S2.M_PI)) {\n      lo = S2.toDecimal(S2.M_PI);\n    }\n    return new S1Interval(lo, hi);\n  }\n\n  /**\n   * Return the smallest interval that contains this interval and the given\n   * interval \"y\".\n   */\n  public  union(y:S1Interval):S1Interval {\n    // The y.is_full() case is handled correctly in all cases by the code\n    // below, but can follow three separate code paths depending on whether\n    // this interval is inverted, is non-inverted but contains Pi, or neither.\n\n    if (y.isEmpty()) {\n      return this;\n    }\n    if (this.fastContains(y.lo)) {\n      if (this.fastContains(y.hi)) {\n        // Either this interval contains y, or the union of the two\n        // intervals is the Full() interval.\n        if (this.containsI(y)) {\n          return this; // is_full() code path\n        }\n        return S1Interval.full();\n      }\n      return new S1Interval(this.lo, this.hi, true);\n    }\n    if (this.fastContains(y.hi)) {\n      return new S1Interval(y.lo, this.hi, true);\n    }\n\n    // This interval contains neither endpoint of y. This means that either y\n    // contains all of this interval, or the two intervals are disjoint.\n    if (this.isEmpty() || y.fastContains(this.lo)) {\n      return y;\n    }\n\n    // Check which pair of endpoints are closer together.\n    let dlo = S1Interval.positiveDistance(y.hi, this.lo);\n    let dhi = S1Interval.positiveDistance(this.hi, y.lo);\n    if (dlo < dhi) {\n      return new S1Interval(y.lo, this.hi, true);\n    } else {\n      return new S1Interval(this.lo, y.hi, true);\n    }\n  }\n\n  /**\n   * Return the smallest interval that contains the intersection of this\n   * interval with \"y\". Note that the region of intersection may consist of two\n   * disjoint intervals.\n   */\n  public intersection(y:S1Interval):S1Interval {\n    // The y.is_full() case is handled correctly in all cases by the code\n    // below, but can follow three separate code paths depending on whether\n    // this interval is inverted, is non-inverted but contains Pi, or neither.\n\n    if (y.isEmpty()) {\n      return S1Interval.empty();\n    }\n    if (this.fastContains(y.lo)) {\n      if (this.fastContains(y.hi)) {\n        // Either this interval contains y, or the region of intersection\n        // consists of two disjoint subintervals. In either case, we want\n        // to return the shorter of the two original intervals.\n        if (y.getLength().lt(this.getLength())) {\n          return y; // is_full() code path\n        }\n        return this;\n      }\n      return new S1Interval(y.lo, this.hi, true);\n    }\n    if (this.fastContains(y.hi)) {\n      return new S1Interval(this.lo, y.hi, true);\n    }\n\n    // This interval contains neither endpoint of y. This means that either y\n    // contains all of this interval, or the two intervals are disjoint.\n\n    if (y.fastContains(this.lo)) {\n      return this; // is_empty() okay here\n    }\n    // assert (!intersects(y));\n    return S1Interval.empty();\n  }\n\n  /**\n   * Return true if the length of the symmetric difference between the two\n   * intervals is at most the given tolerance.\n   */\n  public approxEquals(y:S1Interval, maxError:number=1e-9):boolean {\n    if (this.isEmpty()) {\n      return y.getLength().lte(maxError);\n    }\n    if (y.isEmpty()) {\n      return this.getLength().lte(maxError);\n    }\n\n    return S2.IEEEremainder(y.lo.minus(this.lo), 2 * S2.M_PI).abs()\n            .plus(S2.IEEEremainder(y.hi.minus(this.hi), 2 * S2.M_PI).abs())\n            .lte(maxError);\n  }\n\n\n\n  static empty():S1Interval {\n    return new S1Interval(S2.M_PI, -S2.M_PI, true);\n  }\n\n  static full():S1Interval {\n    return new S1Interval(-S2.M_PI, S2.M_PI, true);\n  }\n\n  static fromPoint(_p:number|decimal.Decimal):S1Interval {\n    let p = S2.toDecimal(_p);\n    if (p.eq(-S2.M_PI)) {\n      p = S2.toDecimal(S2.M_PI);\n    }\n    return new S1Interval(p, p, true);\n  }\n\n\n  /**\n   * Convenience method to construct the minimal interval containing the two\n   * given points. This is equivalent to starting with an empty interval and\n   * calling AddPoint() twice, but it is more efficient.\n   */\n  static fromPointPair(_p1:number|decimal.Decimal, _p2:number|decimal.Decimal):S1Interval {\n    // assert (Math.abs(p1) <= S2.M_PI && Math.abs(p2) <= S2.M_PI);\n    let p1 = S2.toDecimal(_p1);\n    let p2 = S2.toDecimal(_p2);\n    if (p1.eq(-S2.M_PI)) {\n      p1 = S2.toDecimal(S2.M_PI);\n    }\n    if (p2.eq(-S2.M_PI)) {\n      p2 = S2.toDecimal(S2.M_PI);\n    }\n    if (S1Interval.positiveDistance(p1, p2).lte(S2.M_PI)) {\n      return new S1Interval(p1, p2, true);\n    } else {\n      return new S1Interval(p2, p1, true);\n    }\n  }\n\n  /**\n   * Compute the distance from \"a\" to \"b\" in the range [0, 2*Pi). This is\n   * equivalent to (drem(b - a - S2.M_PI, 2 * S2.M_PI) + S2.M_PI), except that\n   * it is more numerically stable (it does not lose precision for very small\n   * positive distances).\n   */\n  public static positiveDistance(_a:number|decimal.Decimal, _b:number|decimal.Decimal):decimal.Decimal {\n    const a = S2.toDecimal(_a);\n    const b = S2.toDecimal(_b);\n    let d = b.minus(a);\n    if (d .gte(0)) {\n      return d;\n    }\n    // We want to ensure that if b == Pi and a == (-Pi + eps),\n    // the return result is approximately 2*Pi and not zero.\n    return b.plus(S2.M_PI).minus(a.minus(S2.M_PI));\n  }\n\n}\n","import {Interval} from \"./Interval\";\nimport {S2} from \"./S2\";\nimport * as decimal from 'decimal.js';\n\n/**\n * An R1Interval represents a closed interval on a unit circle (also known as a\n * 1-dimensional sphere). It is capable of representing the empty interval\n * (containing no points), the full interval (containing all points), and\n * zero-length intervals (containing a single point).\n *\n *  Points are represented by the angle they make with the positive x-axis in\n * the range [-Pi, Pi]. An interval is represented by its lower and upper bounds\n * (both inclusive, since the interval is closed). The lower bound may be\n * greater than the upper bound, in which case the interval is \"inverted\" (i.e.\n * it passes through the point (-1, 0)).\n *\n *  Note that the point (-1, 0) has two valid representations, Pi and -Pi. The\n * normalized representation of this point internally is Pi, so that endpoints\n * of normal intervals are in the range (-Pi, Pi]. However, we take advantage of\n * the point -Pi to construct two special intervals: the Full() interval is\n * [-Pi, Pi], and the Empty() interval is [Pi, -Pi].\n *\n */\n\nexport class R1Interval extends Interval {\n\n\n\n\n\n  /** Return true if the interval is empty, i.e. it contains no points. */\n  public isEmpty() {\n    return this.lo.gt(this.hi);\n  }\n\n  public getCenter():decimal.Decimal {\n    return this.lo.plus(this.hi).dividedBy(2);\n  }\n\n  public getLength():decimal.Decimal {\n    return this.hi.minus(this.lo);\n  }\n\n  public contains(_p:number|decimal.Decimal):boolean {\n    const p = S2.toDecimal(_p);\n    return p.gte(this.lo) && p.lte(this.hi);\n\n  }\n\n  /** Return true if the interior of the interval contains the point 'p'. */\n  public interiorContains(_p:number|decimal.Decimal):boolean {\n    const p = S2.toDecimal(_p);\n    return p.gt(this.lo) && p.lt(this.hi);  }\n\n  /**\n   * Return true if the interval contains the given interval 'y'. Works for\n   * empty, full, and singleton intervals.\n   */\n  public containsI(y:R1Interval):boolean {\n    if (y.isEmpty()) {\n      return true;\n    }\n    return y.lo.gte(this.lo) && y.hi.lte(this.hi);\n  }\n\n\n  public interiorContainsI(y:R1Interval):boolean {\n    if (y.isEmpty()) {\n      return true;\n    }\n    return y.lo.gt(this.lo) && y.hi.lt(this.hi);\n  }\n\n  /**\n   * Return true if this interval intersects the given interval, i.e. if they\n   * have any points in common.\n   */\n  public intersects(y:R1Interval):boolean {\n    if (this.lo.lte(y.lo)) {\n      return y.lo.lte(this.hi) && y.lo.lte(y.hi);\n    } else {\n      return this.lo.lte(y.hi) && this.lo.lte(this.hi);\n    }\n  }\n\n  /**\n   * Return true if the interior of this interval intersects any point of the\n   * given interval (including its boundary).\n   */\n  public interiorIntersects(y:R1Interval):boolean {\n    return y.lo.lt( this.hi) && this.lo.lt(y.hi) && this.lo.lt(this.hi) && y.lo.lte(y.hi);\n  }\n\n  /** Expand the interval so that it contains the given point \"p\". */\n  public addPoint(_p:number|decimal.Decimal):R1Interval {\n    const p = S2.toDecimal(_p);\n    if (this.isEmpty()) {\n      return R1Interval.fromPoint(p);\n    } else if (p.lt(this.lo)) {\n      return new R1Interval(p, this.hi);\n    } else if (p.gt(this.hi)) {\n      return new R1Interval(this.lo, p);\n    } else {\n      return new R1Interval(this.lo, this.hi);\n    }\n  }\n\n  /**\n   * Return an interval that contains all points with a distance \"radius\" of a\n   * point in this interval. Note that the expansion of an empty interval is\n   * always empty.\n   */\n  public  expanded(_radius:number|decimal.Decimal):R1Interval {\n    const radius = S2.toDecimal(_radius);\n    // assert (radius >= 0);\n    if (this.isEmpty()) {\n      return this;\n    }\n    return new R1Interval(this.lo.minus(radius), this.hi.plus(radius));\n  }\n\n  /**\n   * Return the smallest interval that contains this interval and the given\n   * interval \"y\".\n   */\n  public  union(y:R1Interval):R1Interval {\n    if (this.isEmpty()) {\n      return y;\n    }\n    if (y.isEmpty()) {\n      return this;\n    }\n    return new R1Interval(\n        decimal.Decimal.min(this.lo, y.lo),\n        decimal.Decimal.max(this.hi, y.hi)\n    );\n  }\n\n  /**\n   * Return the intersection of this interval with the given interval. Empty\n   * intervals do not need to be special-cased.\n   */\n  public intersection(y:R1Interval):R1Interval {\n    return new R1Interval(\n        decimal.Decimal.max(this.lo, y.lo),\n        decimal.Decimal.min(this.hi, y.hi)\n    );\n  }\n\n  /**\n   * Return true if the length of the symmetric difference between the two\n   * intervals is at most the given tolerance.\n   */\n  public approxEquals(y:R1Interval, maxError:number=1e-15):boolean {\n    if (this.isEmpty()) {\n      return y.getLength().lte(maxError);\n    }\n    if (y.isEmpty()) {\n      return this.getLength().lte( maxError);\n    }\n    return y.lo.minus(this.lo).abs()\n        .plus(y.hi.minus(this.hi).abs())\n        .lte(maxError);\n  }\n\n\n\n  static empty():R1Interval {\n    return new R1Interval(1, 0);\n  }\n\n\n  static fromPoint(p:number|decimal.Decimal):R1Interval {\n    return new R1Interval(p, p);\n  }\n\n  /**\n   * Convenience method to construct the minimal interval containing the two\n   * given points. This is equivalent to starting with an empty interval and\n   * calling AddPoint() twice, but it is more efficient.\n   */\n  static fromPointPair(_p1:number|decimal.Decimal, _p2:number|decimal.Decimal):R1Interval {\n    const p1 = S2.toDecimal(_p1);\n    const p2 = S2.toDecimal(_p2);\n    if (p1.lte(p2)) {\n      return new R1Interval(p1, p2);\n    } else {\n      return new R1Interval(p2, p1);\n    }\n  }\n\n\n\n\n}\n","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {S1Angle} from \"./S1Angle\";\nimport {S2Point} from \"./S2Point\";\nimport {S2} from \"./S2\";\nimport * as decimal from 'decimal.js';\n/**\n * This class represents a point on the unit sphere as a pair of\n * latitude-longitude coordinates. Like the rest of the \"geometry\" package, the\n * intent is to represent spherical geometry as a mathematical abstraction, so\n * functions that are specifically related to the Earth's geometry (e.g.\n * easting/northing conversions) should be put elsewhere.\n *\n */\nexport class S2LatLng {\n\n  /**\n   * Approximate \"effective\" radius of the Earth in meters.\n   */\n  public static EARTH_RADIUS_METERS = 6367000.0;\n\n  /** The center point the lat/lng coordinate system. */\n  public static CENTER = new S2LatLng(0.0, 0.0);\n\n  public latRadians:decimal.Decimal;\n  public lngRadians:decimal.Decimal;\n\n  constructor(latRadians:number|decimal.Decimal, lngRadians:number|decimal.Decimal) {\n    this.latRadians = S2.toDecimal(latRadians);\n    this.lngRadians = S2.toDecimal(lngRadians);\n  }\n\n  get latDegrees():decimal.Decimal {\n    return new S1Angle(this.latRadians).degrees();\n  }\n\n  get lngDegrees():decimal.Decimal {\n    return new S1Angle(this.lngRadians).degrees();\n  }\n\n// Clamps the latitude to the range [-90, 90] degrees, and adds or subtracts\n  // a multiple of 360 degrees to the longitude if necessary to reduce it to\n  // the range [-180, 180].\n  /** Convert an S2LatLng to the equivalent unit-length vector (S2Point). */\n  public  toPoint():S2Point {\n    const phi = this.latRadians;\n    const theta = this.lngRadians;\n    const cosphi = decimal.Decimal.cos(phi);\n\n    return new S2Point(\n        decimal.Decimal.cos(theta).times(cosphi),\n        decimal.Decimal.sin(theta).times(cosphi),\n        decimal.Decimal.sin(phi));\n  }\n\n  /**\n   * Returns a new S2LatLng based on this instance for which {@link #isValid()}\n   * will be {@code true}.\n   * <ul>\n   * <li>Latitude is clipped to the range {@code [-90, 90]}\n   * <li>Longitude is normalized to be in the range {@code [-180, 180]}\n   * </ul>\n   * <p>If the current point is valid then the returned point will have the same\n   * coordinates.\n   */\n  public normalized():S2LatLng {\n    // drem(x, 2 * S2.M_PI) reduces its argument to the range\n    // [-S2.M_PI, S2.M_PI] inclusive, which is what we want here.\n    return new S2LatLng(\n        decimal.Decimal.max(\n            -S2.M_PI_2,\n            decimal.Decimal.min(\n                S2.M_PI_2,\n                this.latRadians\n            )\n        ),\n        S2.IEEEremainder(\n            this.lngRadians,\n            S2.toDecimal(2).times(S2.M_PI)\n        )\n    );\n    // return new S2LatLng(Math.max(-S2.M_PI_2, Math.min(S2.M_PI_2, this.latRadians)),\n    //     S2.IEEEremainder(this.lngRadians, 2 * S2.M_PI));\n  }\n\n  public static fromDegrees(latDegrees:number|decimal.Decimal, lngDegrees:number|decimal.Decimal):S2LatLng {\n\n    return new S2LatLng(S1Angle.degrees(latDegrees).radians, S1Angle.degrees(lngDegrees).radians);\n  }\n\n  static fromPoint(p:S2Point) {\n    return new S2LatLng(\n        S2LatLng.latitude(p).radians,\n        S2LatLng.longitude(p).radians\n    );\n  }\n\n  /**\n   * Return true if the latitude is between -90 and 90 degrees inclusive and the\n   * longitude is between -180 and 180 degrees inclusive.\n   */\n  public isValid():boolean {\n    return this.latRadians.abs().lte(S2.M_PI_2) &&\n        this.lngRadians.abs().lte(S2.M_PI);\n\n  }\n\n\n  /**\n   * Scales this point by the given scaling factor.\n   * Note that there is no guarantee that the new point will be <em>valid</em>.\n   */\n  public  mul(m:decimal.Decimal|number):S2LatLng {\n    return new S2LatLng(this.latRadians.times(m), this.lngRadians.times(m));\n  }\n\n  public static latitude(p:S2Point) {\n    // We use atan2 rather than asin because the input vector is not necessarily\n    // unit length, and atan2 is much more accurate than asin near the poles.\n    return new S1Angle(\n        decimal.Decimal.atan2(\n            p.z,\n            p.x.pow(2)\n                .plus(p.y.pow(2))\n                .sqrt()\n        )\n        // Math.atan2(p.z, Math.sqrt(p.x * p.x + p.y * p.y))\n    );\n  }\n\n  public static longitude(p:S2Point):S1Angle {\n    // Note that atan2(0, 0) is defined to be zero.\n    return new S1Angle(decimal.Decimal.atan2(p.y, p.x));\n  }\n\n  equals(other:S2LatLng):boolean {\n    return other.latRadians === this.latRadians && other.lngRadians === this.lngRadians;\n  }\n\n  pointAtDistance(_distanceInKm:number|decimal.Decimal, _bearingRadians:number|decimal.Decimal) {\n    const distanceInM = S2.toDecimal(_distanceInKm).times(1000);\n    const distanceToRadius = distanceInM.dividedBy(S2LatLng.EARTH_RADIUS_METERS);\n    const bearingRadians = S2.toDecimal(_bearingRadians);\n    this.latRadians.sin();\n    distanceToRadius.cos();\n    const newLat = this.latRadians.sin()\n        .times(distanceToRadius.cos())\n        .plus(\n            this.latRadians.cos()\n                .times(distanceToRadius.sin())\n                .times(bearingRadians.cos())\n        ).asin();\n    const newLng = this.lngRadians\n        .plus(\n            decimal.Decimal.atan2(\n                bearingRadians.sin()\n                    .times(distanceToRadius.sin())\n                    .times(this.latRadians.cos()),\n                distanceToRadius.cos()\n                    .minus(this.latRadians.sin().times(newLat.sin()))\n            )\n        );\n    return new S2LatLng(newLat, newLng);\n  }\n\n  /**\n   * Generates n LatLngs given a distance in km and the number of points wanted.\n   * Generated points will be returned in a Clockwise order starting from North. \n   * @param _distanceInKm\n   * @param nPoints\n   * @returns {S2LatLng[]}\n   */\n  pointsAtDistance(_distanceInKm:number|decimal.Decimal, nPoints:number=4):S2LatLng[] {\n    return Array.apply(null, new Array(nPoints)) // create an array filled of undefined!\n        .map((p, idx) => {\n          return S2.toDecimal(360).dividedBy(nPoints).times(idx);\n        })\n        .map(bearingDegree => S1Angle.degrees(bearingDegree).radians)\n        .map(bearingRadians => this.pointAtDistance(_distanceInKm, bearingRadians));\n\n  }\n \n  getEarthDistance(other:S2LatLng):decimal.Decimal {\n    return this.getDistance(other).radians.times(S2LatLng.EARTH_RADIUS_METERS);\n  }\n\n  getDistance(other:S2LatLng):S1Angle {\n    // This implements the Haversine formula, which is numerically stable for\n    // small distances but only gets about 8 digits of precision for very large\n    // distances (e.g. antipodal points). Note that 8 digits is still accurate\n    // to within about 10cm for a sphere the size of the Earth.\n    //\n    // This could be fixed with another sin() and cos() below, but at that point\n    // you might as well just convert both arguments to S2Points and compute the\n    // distance that way (which gives about 15 digits of accuracy for all\n    // distances).\n\n    const dLat:decimal.Decimal = other.latRadians.minus(this.latRadians).times(0.5).sin();\n    const dLng:decimal.Decimal = other.lngRadians.minus(this.lngRadians).times(0.5).sin();\n    const x = dLat.pow(2)\n        .plus(\n            dLng.pow(2)\n                .times(this.latRadians.cos())\n                .times(other.latRadians.cos())\n        );\n    // double x = dlat * dlat + dlng * dlng * Math.cos(lat1) * Math.cos(lat2);\n\n    return new S1Angle(\n        (S2.toDecimal(2) as decimal.Decimal)\n            .times(\n                decimal.Decimal.atan2(\n                    x.sqrt(),\n                    decimal.Decimal.max(\n                        0,\n                        x.neg().plus(1)\n                    )\n                        .sqrt()\n                )\n            )\n    );\n    // Return the distance (measured along the surface of the sphere) to the\n    // given S2LatLng. This is mathematically equivalent to:\n    //\n    // S1Angle::FromRadians(ToPoint().Angle(o.ToPoint())\n    //\n    // but this implementation is slightly more efficient.\n  }\n\n  public  toString():string {\n    return \"(\" + this.latRadians + \", \" + this.lngRadians + \")\";\n  }\n\n  public toStringDegrees():string {\n    return \"(\" + this.latDegrees + \", \" + this.lngDegrees + \")\";\n  }\n\n  public toGEOJSON() {\n    return {\n      type: 'Feature',\n      geometry: {\n        type: \"Point\",\n        coordinates: [this.lngDegrees.toNumber(), this.latDegrees.toNumber()]\n      },\n      properties: {}\n\n    }\n  }\n}\n","/*\n * Copyright 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport {S2Point} from \"./S2Point\";\nimport {S2} from \"./S2\";\nimport {S1Angle} from \"./S1Angle\";\n\nimport {Decimal} from 'decimal.js';\n/**\n * This class contains various utility functions related to edges. It collects\n * together common code that is needed to implement polygonal geometry such as\n * polylines, loops, and general polygons.\n *\n */\nexport class S2EdgeUtil {\n//   /**\n//    * IEEE floating-point operations have a maximum error of 0.5 ULPS (units in\n//    * the last place). For double-precision numbers, this works out to 2**-53\n//    * (about 1.11e-16) times the magnitude of the result. It is possible to\n//    * analyze the calculation done by getIntersection() and work out the\n//    * worst-case rounding error. I have done a rough version of this, and my\n//    * estimate is that the worst case distance from the intersection point X to\n//    * the great circle through (a0, a1) is about 12 ULPS, or about 1.3e-15. This\n//    * needs to be increased by a factor of (1/0.866) to account for the\n//    * edgeSpliceFraction() in S2PolygonBuilder. Note that the maximum error\n//    * measured by the unittest in 1,000,000 trials is less than 3e-16.\n//    */\n//   public static final S1Angle DEFAULT_INTERSECTION_TOLERANCE = S1Angle.radians(1.5e-15);\n//\n//   /**\n//    * This class allows a vertex chain v0, v1, v2, ... to be efficiently tested\n//    * for intersection with a given fixed edge AB.\n//    */\n//   public static class EdgeCrosser {\n//   // The fields below are all constant.\n//\n//   private final S2Point a;\n//   private final S2Point b;\n//   private final S2Point aCrossB;\n//\n//   // The fields below are updated for each vertex in the chain.\n//\n//   // Previous vertex in the vertex chain.\n//   private S2Point c;\n//   // The orientation of the triangle ACB.\n//   private int acb;\n//\n//   /**\n//    * AB is the given fixed edge, and C is the first vertex of the vertex\n//    * chain. All parameters must point to fixed storage that persists for the\n//    * lifetime of the EdgeCrosser object.\n//    */\n//   public EdgeCrosser(S2Point a, S2Point b, S2Point c) {\n//   this.a = a;\n//   this.b = b;\n//   this.aCrossB = S2Point.crossProd(a, b);\n//   restartAt(c);\n// }\n//\n// /**\n//  * Call this function when your chain 'jumps' to a new place.\n//  */\n// public void restartAt(S2Point c) {\n//   this.c = c;\n//   this.acb = -S2.robustCCW(this.a, this.b, c, this.aCrossB);\n// }\n//\n// /**\n//  * This method is equivalent to calling the S2EdgeUtil.robustCrossing()\n//  * function (defined below) on the edges AB and CD. It returns +1 if there\n//  * is a crossing, -1 if there is no crossing, and 0 if two points from\n//  * different edges are the same. Returns 0 or -1 if either edge is\n//  * degenerate. As a side effect, it saves vertex D to be used as the next\n//  * vertex C.\n//  */\n// public int robustCrossing(S2Point d) {\n//   // For there to be an edge crossing, the triangles ACB, CBD, BDA, DAC must\n//   // all be oriented the same way (CW or CCW). We keep the orientation\n//   // of ACB as part of our state. When each new point D arrives, we\n//   // compute the orientation of BDA and check whether it matches ACB.\n//   // This checks whether the points C and D are on opposite sides of the\n//   // great circle through AB.\n//\n//   // Recall that robustCCW is invariant with respect to rotating its\n//   // arguments, i.e. ABC has the same orientation as BDA.\n//   int bda = S2.robustCCW(this.a, this.b, d, this.aCrossB);\n//   int result;\n//\n//   if (bda == -this.acb && bda != 0) {\n//     // Most common case -- triangles have opposite orientations.\n//     result = -1;\n//   } else if ((bda & this.acb) == 0) {\n//     // At least one value is zero -- two vertices are identical.\n//     result = 0;\n//   } else {\n//     // assert (bda == acb && bda != 0);\n//     result = robustCrossingInternal(d); // Slow path.\n//   }\n//   // Now save the current vertex D as the next vertex C, and also save the\n//   // orientation of the new triangle ACB (which is opposite to the current\n//   // triangle BDA).\n//   this.c = d;\n//   this.acb = -bda;\n//   return result;\n// }\n//\n// /**\n//  * This method is equivalent to the S2EdgeUtil.edgeOrVertexCrossing() method\n//  * defined below. It is similar to robustCrossing, but handles cases where\n//  * two vertices are identical in a way that makes it easy to implement\n//  * point-in-polygon containment tests.\n//  */\n// public boolean edgeOrVertexCrossing(S2Point d) {\n//   // We need to copy c since it is clobbered by robustCrossing().\n//   S2Point c2 = new S2Point(this.c.get(0), this.c.get(1), this.c.get(2));\n//\n//   int crossing = robustCrossing(d);\n//   if (crossing < 0) {\n//     return false;\n//   }\n//   if (crossing > 0) {\n//     return true;\n//   }\n//\n//   return vertexCrossing(this.a, this.b, c2, d);\n// }\n//\n// /**\n//  * This function handles the \"slow path\" of robustCrossing().\n//  */\n// private int robustCrossingInternal(S2Point d) {\n//   // ACB and BDA have the appropriate orientations, so now we check the\n//   // triangles CBD and DAC.\n//   S2Point cCrossD = S2Point.crossProd(this.c, d);\n//   int cbd = -S2.robustCCW(this.c, d, this.b, cCrossD);\n//   if (cbd != this.acb) {\n//     return -1;\n//   }\n//\n//   int dac = S2.robustCCW(this.c, d, this.a, cCrossD);\n//   return (dac == this.acb) ? 1 : -1;\n// }\n// }\n//\n// /**\n//  * This class computes a bounding rectangle that contains all edges defined by\n//  * a vertex chain v0, v1, v2, ... All vertices must be unit length. Note that\n//  * the bounding rectangle of an edge can be larger than the bounding rectangle\n//  * of its endpoints, e.g. consider an edge that passes through the north pole.\n//  */\n// public static class RectBounder {\n//   // The previous vertex in the chain.\n//   private S2Point a;\n//\n//   // The corresponding latitude-longitude.\n//   private S2LatLng aLatLng;\n//\n//   // The current bounding rectangle.\n//   private S2LatLngRect bound;\n//\n//   public RectBounder() {\n//     this.bound = S2LatLngRect.empty();\n//   }\n//\n//   /**\n//    * This method is called to add each vertex to the chain. 'b' must point to\n//    * fixed storage that persists for the lifetime of the RectBounder.\n//    */\n//   public void addPoint(S2Point b) {\n//   // assert (S2.isUnitLength(b));\n//\n//   S2LatLng bLatLng = new S2LatLng(b);\n//\n//   if (this.bound.isEmpty()) {\n//   this.bound = this.bound.addPoint(bLatLng);\n// } else {\n//   // We can't just call bound.addPoint(bLatLng) here, since we need to\n//   // ensure that all the longitudes between \"a\" and \"b\" are included.\n//   this.bound = this.bound.union(S2LatLngRect.fromPointPair(this.aLatLng, bLatLng));\n//\n//   // Check whether the min/max latitude occurs in the edge interior.\n//   // We find the normal to the plane containing AB, and then a vector\n//   // \"dir\" in this plane that also passes through the equator. We use\n//   // RobustCrossProd to ensure that the edge normal is accurate even\n//   // when the two points are very close together.\n//   S2Point aCrossB = S2.robustCrossProd(this.a, b);\n//   S2Point dir = S2Point.crossProd(aCrossB, new S2Point(0, 0, 1));\n//   double da = dir.dotProd(this.a);\n//   double db = dir.dotProd(b);\n//\n//   if (da * db < 0) {\n//     // Minimum/maximum latitude occurs in the edge interior. This affects\n//     // the latitude bounds but not the longitude bounds.\n//     double absLat = Math.acos(Math.abs(aCrossB.get(2) / aCrossB.norm()));\n//     R1Interval lat = this.bound.lat();\n//     if (da < 0) {\n//       // It's possible that absLat < lat.lo() due to numerical errors.\n//       lat = new R1Interval(lat.lo(), Math.max(absLat, this.bound.lat().hi()));\n//     } else {\n//       lat = new R1Interval(Math.min(-absLat, this.bound.lat().lo()), lat.hi());\n//     }\n//     this.bound = new S2LatLngRect(lat, this.bound.lng());\n//   }\n// }\n// this.a = b;\n// this.aLatLng = bLatLng;\n// }\n//\n// /**\n//  * Return the bounding rectangle of the edge chain that connects the\n//  * vertices defined so far.\n//  */\n// public S2LatLngRect getBound() {\n//   return this.bound;\n// }\n//\n// }\n//\n// /**\n//  * The purpose of this class is to find edges that intersect a given XYZ\n//  * bounding box. It can be used as an efficient rejection test when attempting to\n//  * find edges that intersect a given region. It accepts a vertex chain v0, v1,\n//  * v2, ... and returns a boolean value indicating whether each edge intersects\n//  * the specified bounding box.\n//  *\n//  * We use XYZ intervals instead of something like longitude intervals because\n//  * it is cheap to collect from S2Point lists and any slicing strategy should\n//  * give essentially equivalent results.  See S2Loop for an example of use.\n//  */\n// public static class XYZPruner {\n//   private S2Point lastVertex;\n//\n//   // The region to be tested against.\n//   private boolean boundSet;\n//   private double xmin;\n//   private double ymin;\n//   private double zmin;\n//   private double xmax;\n//   private double ymax;\n//   private double zmax;\n//   private double maxDeformation;\n//\n//   public XYZPruner() {\n//     this.boundSet = false;\n//   }\n//\n//   /**\n//    * Accumulate a bounding rectangle from provided edges.\n//    *\n//    * @param from start of edge\n//    * @param to end of edge.\n//    */\n//   public void addEdgeToBounds(S2Point from, S2Point to) {\n//   if (!this.boundSet) {\n//   this.boundSet = true;\n//   this.xmin = this.xmax = from.x;\n//   this.ymin = this.ymax = from.y;\n//   this.zmin = this.zmax = from.z;\n// }\n// this.xmin = Math.min(this.xmin, Math.min(to.x, from.x));\n// this.ymin = Math.min(this.ymin, Math.min(to.y, from.y));\n// this.zmin = Math.min(this.zmin, Math.min(to.z, from.z));\n// this.xmax = Math.max(this.xmax, Math.max(to.x, from.x));\n// this.ymax = Math.max(this.ymax, Math.max(to.y, from.y));\n// this.zmax = Math.max(this.zmax, Math.max(to.z, from.z));\n//\n// // Because our arcs are really geodesics on the surface of the earth\n// // an edge can have intermediate points outside the xyz bounds implicit\n// // in the end points.  Based on the length of the arc we compute a\n// // generous bound for the maximum amount of deformation.  For small edges\n// // it will be very small but for some large arcs (ie. from (1N,90W) to\n// // (1N,90E) the path can be wildly deformed.  I did a bunch of\n// // experiments with geodesics to get safe bounds for the deformation.\n// double approxArcLen =\n//     Math.abs(from.x - to.x) + Math.abs(from.y - to.y) + Math.abs(from.z - to.z);\n// if (approxArcLen < 0.025) { // less than 2 degrees\n//   this.maxDeformation = Math.max(this.maxDeformation, approxArcLen * 0.0025);\n// } else if (approxArcLen < 1.0) { // less than 90 degrees\n//   this.maxDeformation = Math.max(this.maxDeformation, approxArcLen * 0.11);\n// } else {\n//   this.maxDeformation = approxArcLen * 0.5;\n// }\n// }\n//\n// public void setFirstIntersectPoint(S2Point v0) {\n//   this.xmin = this.xmin - this.maxDeformation;\n//   this.ymin = this.ymin - this.maxDeformation;\n//   this.zmin = this.zmin - this.maxDeformation;\n//   this.xmax = this.xmax + this.maxDeformation;\n//   this.ymax = this.ymax + this.maxDeformation;\n//   this.zmax = this.zmax + this.maxDeformation;\n//   this.lastVertex = v0;\n// }\n//\n// /**\n//  * Returns true if the edge going from the last point to this point passes\n//  * through the pruner bounding box, otherwise returns false.  So the\n//  * method returns false if we are certain there is no intersection, but it\n//  * may return true when there turns out to be no intersection.\n//  */\n// public boolean intersects(S2Point v1) {\n//   boolean result = true;\n//\n//   if ((v1.x < this.xmin && this.lastVertex.x < this.xmin) || (v1.x > this.xmax && this.lastVertex.x > this.xmax)) {\n//     result = false;\n//   } else if ((v1.y < this.ymin && this.lastVertex.y < this.ymin) || (v1.y > this.ymax && this.lastVertex.y > this.ymax)) {\n//     result = false;\n//   } else if ((v1.z < this.zmin && this.lastVertex.z < this.zmin) || (v1.z > this.zmax && this.lastVertex.z > this.zmax)) {\n//     result = false;\n//   }\n//\n//   this.lastVertex = v1;\n//   return result;\n// }\n// }\n//\n// /**\n//  * The purpose of this class is to find edges that intersect a given longitude\n//  * interval. It can be used as an efficient rejection test when attempting to\n//  * find edges that intersect a given region. It accepts a vertex chain v0, v1,\n//  * v2, ... and returns a boolean value indicating whether each edge intersects\n//  * the specified longitude interval.\n//  *\n//  * This class is not currently used as the XYZPruner is preferred for\n//  * S2Loop, but this should be usable in similar circumstances.  Be wary\n//  * of the cost of atan2() in conversions from S2Point to longitude!\n//  */\n// public static class LongitudePruner {\n//   // The interval to be tested against.\n//   private S1Interval interval;\n//\n//   // The longitude of the next v0.\n//   private double lng0;\n//\n//   /**\n//    *'interval' is the longitude interval to be tested against, and 'v0' is\n//    * the first vertex of edge chain.\n//    */\n//   public LongitudePruner(S1Interval interval, S2Point v0) {\n//   this.interval = interval;\n//   this.lng0 = S2LatLng.longitude(v0).radians();\n// }\n//\n// /**\n//  * Returns true if the edge (v0, v1) intersects the given longitude\n//  * interval, and then saves 'v1' to be used as the next 'v0'.\n//  */\n// public boolean intersects(S2Point v1) {\n//   double lng1 = S2LatLng.longitude(v1).radians();\n//   boolean result = this.interval.intersects(S1Interval.fromPointPair(this.lng0, lng1));\n//   this.lng0 = lng1;\n//   return result;\n// }\n// }\n//\n// /**\n//  * A wedge relation's test method accepts two edge chains A=(a0,a1,a2) and\n//  * B=(b0,b1,b2) where a1==b1, and returns either -1, 0, or 1 to indicate the\n//  * relationship between the region to the left of A and the region to the left\n//  * of B. Wedge relations are used to determine the local relationship between\n//  * two polygons that share a common vertex.\n//  *\n//  *  All wedge relations require that a0 != a2 and b0 != b2. Other degenerate\n//  * cases (such as a0 == b2) are handled as expected. The parameter \"ab1\"\n//  * denotes the common vertex a1 == b1.\n//  */\n// public interface WedgeRelation {\n//   int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2);\n// }\n//\n// public static class WedgeContains implements WedgeRelation {\n//   /**\n//    * Given two edge chains (see WedgeRelation above), this function returns +1\n//    * if the region to the left of A contains the region to the left of B, and\n//    * 0 otherwise.\n//    */\n//   @Override\n//   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n//   // For A to contain B (where each loop interior is defined to be its left\n//   // side), the CCW edge order around ab1 must be a2 b2 b0 a0. We split\n//   // this test into two parts that test three vertices each.\n//   return S2.orderedCCW(a2, b2, b0, ab1) && S2.orderedCCW(b0, a0, a2, ab1) ? 1 : 0;\n// }\n// }\n//\n// public static class WedgeIntersects implements WedgeRelation {\n//   /**\n//    * Given two edge chains (see WedgeRelation above), this function returns -1\n//    * if the region to the left of A intersects the region to the left of B,\n//    * and 0 otherwise. Note that regions are defined such that points along a\n//    * boundary are contained by one side or the other, not both. So for\n//    * example, if A,B,C are distinct points ordered CCW around a vertex O, then\n//    * the wedges BOA, AOC, and COB do not intersect.\n//    */\n//   @Override\n//   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n//   // For A not to intersect B (where each loop interior is defined to be\n//   // its left side), the CCW edge order around ab1 must be a0 b2 b0 a2.\n//   // Note that it's important to write these conditions as negatives\n//   // (!OrderedCCW(a,b,c,o) rather than Ordered(c,b,a,o)) to get correct\n//   // results when two vertices are the same.\n//   return (S2.orderedCCW(a0, b2, b0, ab1) && S2.orderedCCW(b0, a2, a0, ab1) ? 0 : -1);\n// }\n// }\n//\n// public static class WedgeContainsOrIntersects implements WedgeRelation {\n//   /**\n//    * Given two edge chains (see WedgeRelation above), this function returns +1\n//    * if A contains B, 0 if A and B are disjoint, and -1 if A intersects but\n//    * does not contain B.\n//    */\n//   @Override\n//   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n//   // This is similar to WedgeContainsOrCrosses, except that we want to\n//   // distinguish cases (1) [A contains B], (3) [A and B are disjoint],\n//   // and (2,4,5,6) [A intersects but does not contain B].\n//\n//   if (S2.orderedCCW(a0, a2, b2, ab1)) {\n//   // We are in case 1, 5, or 6, or case 2 if a2 == b2.\n//   return S2.orderedCCW(b2, b0, a0, ab1) ? 1 : -1; // Case 1 vs. 2,5,6.\n// }\n// // We are in cases 2, 3, or 4.\n// if (!S2.orderedCCW(a2, b0, b2, ab1)) {\n//   return 0; // Case 3.\n// }\n//\n// // We are in case 2 or 4, or case 3 if a2 == b0.\n// return (a2.equals(b0)) ? 0 : -1; // Case 3 vs. 2,4.\n// }\n// }\n//\n// public static class WedgeContainsOrCrosses implements WedgeRelation {\n//   /**\n//    * Given two edge chains (see WedgeRelation above), this function returns +1\n//    * if A contains B, 0 if B contains A or the two wedges do not intersect,\n//    * and -1 if the edge chains A and B cross each other (i.e. if A intersects\n//    * both the interior and exterior of the region to the left of B). In\n//    * degenerate cases where more than one of these conditions is satisfied,\n//    * the maximum possible result is returned. For example, if A == B then the\n//    * result is +1.\n//    */\n//   @Override\n//   public int test(S2Point a0, S2Point ab1, S2Point a2, S2Point b0, S2Point b2) {\n//   // There are 6 possible edge orderings at a shared vertex (all\n//   // of these orderings are circular, i.e. abcd == bcda):\n//   //\n//   // (1) a2 b2 b0 a0: A contains B\n//   // (2) a2 a0 b0 b2: B contains A\n//   // (3) a2 a0 b2 b0: A and B are disjoint\n//   // (4) a2 b0 a0 b2: A and B intersect in one wedge\n//   // (5) a2 b2 a0 b0: A and B intersect in one wedge\n//   // (6) a2 b0 b2 a0: A and B intersect in two wedges\n//   //\n//   // In cases (4-6), the boundaries of A and B cross (i.e. the boundary\n//   // of A intersects the interior and exterior of B and vice versa).\n//   // Thus we want to distinguish cases (1), (2-3), and (4-6).\n//   //\n//   // Note that the vertices may satisfy more than one of the edge\n//   // orderings above if two or more vertices are the same. The tests\n//   // below are written so that we take the most favorable\n//   // interpretation, i.e. preferring (1) over (2-3) over (4-6). In\n//   // particular note that if orderedCCW(a,b,c,o) returns true, it may be\n//   // possible that orderedCCW(c,b,a,o) is also true (if a == b or b == c).\n//\n//   if (S2.orderedCCW(a0, a2, b2, ab1)) {\n//   // The cases with this vertex ordering are 1, 5, and 6,\n//   // although case 2 is also possible if a2 == b2.\n//   if (S2.orderedCCW(b2, b0, a0, ab1)) {\n//   return 1; // Case 1 (A contains B)\n// }\n//\n// // We are in case 5 or 6, or case 2 if a2 == b2.\n// return (a2.equals(b2)) ? 0 : -1; // Case 2 vs. 5,6.\n// }\n// // We are in case 2, 3, or 4.\n// return S2.orderedCCW(a0, b0, a2, ab1) ? 0 : -1; // Case 2,3 vs. 4.\n// }\n// }\n//\n// /**\n//  * Return true if edge AB crosses CD at a point that is interior to both\n//  * edges. Properties:\n//  *\n//  *  (1) simpleCrossing(b,a,c,d) == simpleCrossing(a,b,c,d) (2)\n//  * simpleCrossing(c,d,a,b) == simpleCrossing(a,b,c,d)\n//  */\n// public static boolean simpleCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n//   // We compute simpleCCW() for triangles ACB, CBD, BDA, and DAC. All\n//   // of these triangles need to have the same orientation (CW or CCW)\n//   // for an intersection to exist. Note that this is slightly more\n//   // restrictive than the corresponding definition for planar edges,\n//   // since we need to exclude pairs of line segments that would\n//   // otherwise \"intersect\" by crossing two antipodal points.\n//\n//   S2Point ab = S2Point.crossProd(a, b);\n//   double acb = -(ab.dotProd(c));\n//   double bda = ab.dotProd(d);\n//   if (acb * bda <= 0) {\n//     return false;\n//   }\n//\n//   S2Point cd = S2Point.crossProd(c, d);\n//   double cbd = -(cd.dotProd(b));\n//   double dac = cd.dotProd(a);\n//   return (acb * cbd > 0) && (acb * dac > 0);\n// }\n//\n// /**\n//  * Like SimpleCrossing, except that points that lie exactly on a line are\n//  * arbitrarily classified as being on one side or the other (according to the\n//  * rules of S2.robustCCW). It returns +1 if there is a crossing, -1 if there\n//  * is no crossing, and 0 if any two vertices from different edges are the\n//  * same. Returns 0 or -1 if either edge is degenerate. Properties of\n//  * robustCrossing:\n//  *\n//  *  (1) robustCrossing(b,a,c,d) == robustCrossing(a,b,c,d) (2)\n//  * robustCrossing(c,d,a,b) == robustCrossing(a,b,c,d) (3)\n//  * robustCrossing(a,b,c,d) == 0 if a==c, a==d, b==c, b==d (3)\n//  * robustCrossing(a,b,c,d) <= 0 if a==b or c==d\n//  *\n//  *  Note that if you want to check an edge against a *chain* of other edges,\n//  * it is much more efficient to use an EdgeCrosser (above).\n//  */\n// public static int robustCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n//   // For there to be a crossing, the triangles ACB, CBD, BDA, DAC must\n//   // all have the same orientation (clockwise or counterclockwise).\n//   //\n//   // First we compute the orientation of ACB and BDA. We permute the\n//   // arguments to robustCCW so that we can reuse the cross-product of A and B.\n//   // Recall that when the arguments to robustCCW are permuted, the sign of the\n//   // result changes according to the sign of the permutation. Thus ACB and\n//   // ABC are oppositely oriented, while BDA and ABD are the same.\n//   S2Point aCrossB = S2Point.crossProd(a, b);\n//   int acb = -S2.robustCCW(a, b, c, aCrossB);\n//   int bda = S2.robustCCW(a, b, d, aCrossB);\n//\n//   // If any two vertices are the same, the result is degenerate.\n//   if ((bda & acb) == 0) {\n//     return 0;\n//   }\n//\n//   // If ABC and BDA have opposite orientations (the most common case),\n//   // there is no crossing.\n//   if (bda != acb) {\n//     return -1;\n//   }\n//\n//   // Otherwise we compute the orientations of CBD and DAC, and check whether\n//   // their orientations are compatible with the other two triangles.\n//   S2Point cCrossD = S2Point.crossProd(c, d);\n//   int cbd = -S2.robustCCW(c, d, b, cCrossD);\n//   if (cbd != acb) {\n//     return -1;\n//   }\n//\n//   int dac = S2.robustCCW(c, d, a, cCrossD);\n//   return (dac == acb) ? 1 : -1;\n// }\n//\n// /**\n//  * Given two edges AB and CD where at least two vertices are identical (i.e.\n//  * robustCrossing(a,b,c,d) == 0), this function defines whether the two edges\n//  * \"cross\" in a such a way that point-in-polygon containment tests can be\n//  * implemented by counting the number of edge crossings. The basic rule is\n//  * that a \"crossing\" occurs if AB is encountered after CD during a CCW sweep\n//  * around the shared vertex starting from a fixed reference point.\n//  *\n//  *  Note that according to this rule, if AB crosses CD then in general CD does\n//  * not cross AB. However, this leads to the correct result when counting\n//  * polygon edge crossings. For example, suppose that A,B,C are three\n//  * consecutive vertices of a CCW polygon. If we now consider the edge\n//  * crossings of a segment BP as P sweeps around B, the crossing number changes\n//  * parity exactly when BP crosses BA or BC.\n//  *\n//  *  Useful properties of VertexCrossing (VC):\n//  *\n//  *  (1) VC(a,a,c,d) == VC(a,b,c,c) == false (2) VC(a,b,a,b) == VC(a,b,b,a) ==\n//  * true (3) VC(a,b,c,d) == VC(a,b,d,c) == VC(b,a,c,d) == VC(b,a,d,c) (3) If\n//  * exactly one of a,b equals one of c,d, then exactly one of VC(a,b,c,d) and\n//  * VC(c,d,a,b) is true\n//  *\n//  * It is an error to call this method with 4 distinct vertices.\n//  */\n// public static boolean vertexCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n//   // If A == B or C == D there is no intersection. We need to check this\n//   // case first in case 3 or more input points are identical.\n//   if (a.equals(b) || c.equals(d)) {\n//     return false;\n//   }\n//\n//   // If any other pair of vertices is equal, there is a crossing if and only\n//   // if orderedCCW() indicates that the edge AB is further CCW around the\n//   // shared vertex than the edge CD.\n//   if (a.equals(d)) {\n//     return S2.orderedCCW(S2.ortho(a), c, b, a);\n//   }\n//   if (b.equals(c)) {\n//     return S2.orderedCCW(S2.ortho(b), d, a, b);\n//   }\n//   if (a.equals(c)) {\n//     return S2.orderedCCW(S2.ortho(a), d, b, a);\n//   }\n//   if (b.equals(d)) {\n//     return S2.orderedCCW(S2.ortho(b), c, a, b);\n//   }\n//\n//   // assert (false);\n//   return false;\n// }\n//\n// /**\n//  * A convenience function that calls robustCrossing() to handle cases where\n//  * all four vertices are distinct, and VertexCrossing() to handle cases where\n//  * two or more vertices are the same. This defines a crossing function such\n//  * that point-in-polygon containment tests can be implemented by simply\n//  * counting edge crossings.\n//  */\n// public static boolean edgeOrVertexCrossing(S2Point a, S2Point b, S2Point c, S2Point d) {\n//   int crossing = robustCrossing(a, b, c, d);\n//   if (crossing < 0) {\n//     return false;\n//   }\n//   if (crossing > 0) {\n//     return true;\n//   }\n//   return vertexCrossing(a, b, c, d);\n// }\n//\n// static class CloserResult {\n//   private double dmin2;\n//   private S2Point vmin;\n//\n//   public double getDmin2() {\n//   return this.dmin2;\n// }\n//\n//   public S2Point getVmin() {\n//   return this.vmin;\n// }\n//\n//   public CloserResult(double dmin2, S2Point vmin) {\n//   this.dmin2 = dmin2;\n//   this.vmin = vmin;\n// }\n//\n// public void replaceIfCloser(S2Point x, S2Point y) {\n//   // If the squared distance from x to y is less than dmin2, then replace\n//   // vmin by y and update dmin2 accordingly.\n//   double d2 = S2Point.minus(x, y).norm2();\n//   if (d2 < this.dmin2 || (d2 == this.dmin2 && y.lessThan(this.vmin))) {\n//     this.dmin2 = d2;\n//     this.vmin = y;\n//   }\n// }\n// }\n//\n// /*\n//  * Given two edges AB and CD such that robustCrossing() is true, return their\n//  * intersection point. Useful properties of getIntersection (GI):\n//  *\n//  * (1) GI(b,a,c,d) == GI(a,b,d,c) == GI(a,b,c,d) (2) GI(c,d,a,b) ==\n//  * GI(a,b,c,d)\n//  *\n//  * The returned intersection point X is guaranteed to be close to the edges AB\n//  * and CD, but if the edges intersect at a very small angle then X may not be\n//  * close to the true mathematical intersection point P. See the description of\n//  * \"DEFAULT_INTERSECTION_TOLERANCE\" below for details.\n//  */\n// public static S2Point getIntersection(S2Point a0, S2Point a1, S2Point b0, S2Point b1) {\n//   Preconditions.checkArgument(robustCrossing(a0, a1, b0, b1) > 0,\n//       \"Input edges a0a1 and b0b1 muct have a true robustCrossing.\");\n//\n//   // We use robustCrossProd() to get accurate results even when two endpoints\n//   // are close together, or when the two line segments are nearly parallel.\n//   S2Point aNorm = S2Point.normalize(S2.robustCrossProd(a0, a1));\n//   S2Point bNorm = S2Point.normalize(S2.robustCrossProd(b0, b1));\n//   S2Point x = S2Point.normalize(S2.robustCrossProd(aNorm, bNorm));\n//\n//   // Make sure the intersection point is on the correct side of the sphere.\n//   // Since all vertices are unit length, and edges are less than 180 degrees,\n//   // (a0 + a1) and (b0 + b1) both have positive dot product with the\n//   // intersection point. We use the sum of all vertices to make sure that the\n//   // result is unchanged when the edges are reversed or exchanged.\n//   if (x.dotProd(S2Point.add(S2Point.add(a0, a1), S2Point.add(b0, b1))) < 0) {\n//     x = S2Point.neg(x);\n//   }\n//\n//   // The calculation above is sufficient to ensure that \"x\" is within\n//   // DEFAULT_INTERSECTION_TOLERANCE of the great circles through (a0,a1) and\n//   // (b0,b1).\n//   // However, if these two great circles are very close to parallel, it is\n//   // possible that \"x\" does not lie between the endpoints of the given line\n//   // segments. In other words, \"x\" might be on the great circle through\n//   // (a0,a1) but outside the range covered by (a0,a1). In this case we do\n//   // additional clipping to ensure that it does.\n//\n//   if (S2.orderedCCW(a0, x, a1, aNorm) && S2.orderedCCW(b0, x, b1, bNorm)) {\n//     return x;\n//   }\n//\n//   // Find the acceptable endpoint closest to x and return it. An endpoint is\n//   // acceptable if it lies between the endpoints of the other line segment.\n//   CloserResult r = new CloserResult(10, x);\n//   if (S2.orderedCCW(b0, a0, b1, bNorm)) {\n//     r.replaceIfCloser(x, a0);\n//   }\n//   if (S2.orderedCCW(b0, a1, b1, bNorm)) {\n//     r.replaceIfCloser(x, a1);\n//   }\n//   if (S2.orderedCCW(a0, b0, a1, aNorm)) {\n//     r.replaceIfCloser(x, b0);\n//   }\n//   if (S2.orderedCCW(a0, b1, a1, aNorm)) {\n//     r.replaceIfCloser(x, b1);\n//   }\n//   return r.getVmin();\n// }\n//\n// /**\n//  * Given a point X and an edge AB, return the distance ratio AX / (AX + BX).\n//  * If X happens to be on the line segment AB, this is the fraction \"t\" such\n//  * that X == Interpolate(A, B, t). Requires that A and B are distinct.\n//  */\n// public static double getDistanceFraction(S2Point x, S2Point a0, S2Point a1) {\n//   Preconditions.checkArgument(!a0.equals(a1));\n//   double d0 = x.angle(a0);\n//   double d1 = x.angle(a1);\n//   return d0 / (d0 + d1);\n// }\n//\n// /**\n//  * Return the minimum distance from X to any point on the edge AB. The result\n//  * is very accurate for small distances but may have some numerical error if\n//  * the distance is large (approximately Pi/2 or greater). The case A == B is\n//  * handled correctly. Note: x, a and b must be of unit length. Throws\n//  * IllegalArgumentException if this is not the case.\n//  */\n// public static getDistance(x:S2Point , a:S2Point , b:S2Point ):S1Angle  {\n//   return this.getDistance(x, a, b, S2.robustCrossProd(a, b));\n// }\n\n/**\n * A slightly more efficient version of getDistance() where the cross product\n * of the two endpoints has been precomputed. The cross product does not need\n * to be normalized, but should be computed using S2.robustCrossProd() for the\n * most accurate results.\n */\npublic static getDistance(x:S2Point , a:S2Point , b:S2Point , aCrossB:S2Point=S2.robustCrossProd(a,b) ):S1Angle  {\n  // Preconditions.checkArgument(S2.isUnitLength(x));\n  // Preconditions.checkArgument(S2.isUnitLength(a));\n  // Preconditions.checkArgument(S2.isUnitLength(b));\n\n  // There are three cases. If X is located in the spherical wedge defined by\n  // A, B, and the axis A x B, then the closest point is on the segment AB.\n  // Otherwise the closest point is either A or B; the dividing line between\n  // these two cases is the great circle passing through (A x B) and the\n  // midpoint of AB.\n\n  if (S2.simpleCCW(aCrossB, a, x) && S2.simpleCCW(x, b, aCrossB)) {\n    // The closest point to X lies on the segment AB. We compute the distance\n    // to the corresponding great circle. The result is accurate for small\n    // distances but not necessarily for large distances (approaching Pi/2).\n\n    const sinDist = x.dotProd(aCrossB).abs().dividedBy( aCrossB.norm());\n    return new S1Angle(Decimal.asin(Decimal.min(1.0, sinDist)));\n  }\n\n  // Otherwise, the closest point is either A or B. The cheapest method is\n  // just to compute the minimum of the two linear (as opposed to spherical)\n  // distances and convert the result to an angle. Again, this method is\n  // accurate for small but not large distances (approaching Pi).\n\n  const linearDist2 = Decimal.min(S2Point.minus(x, a).norm2(), S2Point.minus(x, b).norm2());\n  return new S1Angle(\n      Decimal.asin(\n          Decimal.min(\n              1.0,\n              linearDist2.sqrt().times(0.5)\n          )\n      ).times(2)\n  );\n}\n//\n// /**\n//  * Returns the point on edge AB closest to X. x, a and b must be of unit\n//  * length. Throws IllegalArgumentException if this is not the case.\n//  *\n//  */\n// public static S2Point getClosestPoint(S2Point x, S2Point a, S2Point b) {\n//   Preconditions.checkArgument(S2.isUnitLength(x));\n//   Preconditions.checkArgument(S2.isUnitLength(a));\n//   Preconditions.checkArgument(S2.isUnitLength(b));\n//\n//   S2Point crossProd = S2.robustCrossProd(a, b);\n//   // Find the closest point to X along the great circle through AB.\n//   S2Point p = S2Point.minus(x, S2Point.mul(crossProd, x.dotProd(crossProd) / crossProd.norm2()));\n//\n//   // If p is on the edge AB, then it's the closest point.\n//   if (S2.simpleCCW(crossProd, a, p) && S2.simpleCCW(p, b, crossProd)) {\n//     return S2Point.normalize(p);\n//   }\n//   // Otherwise, the closest point is either A or B.\n//   return S2Point.minus(x, a).norm2() <= S2Point.minus(x, b).norm2() ? a : b;\n// }\n//\n// /** Constructor is private so that this class is never instantiated. */\n// private S2EdgeUtil() {\n// }\n}\n","import {S1Interval} from \"./S1Interval\";\nimport {R1Interval} from \"./R1Interval\";\nimport {S2LatLng} from \"./S2LatLng\";\nimport {S2Region} from \"./S2Region\";\nimport {S2} from \"./S2\";\nimport {S2Point} from \"./S2Point\";\nimport {S1Angle} from \"./S1Angle\";\nimport {S2Cell} from \"./S2Cell\";\nimport {S2EdgeUtil} from \"./S2EdgeUtil\";\nimport {S2Cap} from \"./S2Cap\";\nimport * as decimal from 'decimal.js';\nexport class S2LatLngRect implements S2Region {\n  constructor(public lat:R1Interval, public lng:S1Interval) {\n\n  }\n\n  static fromLatLng(lo:S2LatLng, hi:S2LatLng):S2LatLngRect {\n    return new S2LatLngRect(\n        new R1Interval(\n            lo.latRadians,\n            hi.latRadians\n        ),\n        new S1Interval(\n            lo.lngRadians,\n            hi.lngRadians\n        )\n    );\n  }\n\n\n  /** The canonical empty rectangle */\n  public static  empty():S2LatLngRect {\n    return new S2LatLngRect(R1Interval.empty(), S1Interval.empty());\n  }\n\n  /** The canonical full rectangle. */\n  public static  full():S2LatLngRect {\n    return new S2LatLngRect(S2LatLngRect.fullLat(), S1Interval.full());\n  }\n\n  /** The full allowable range of latitudes. */\n  public static fullLat() {\n    return new R1Interval(-S2.M_PI_2, S2.M_PI_2);\n  }\n\n\n  /**\n   * Construct a rectangle from a center point (in lat-lng space) and size in\n   * each dimension. If size.lng is greater than 360 degrees it is clamped,\n   * and latitudes greater than +/- 90 degrees are also clamped. So for example,\n   * FromCenterSize((80,170),(20,20)) -> (lo=(60,150),hi=(90,-170)).\n   */\n  public static  fromCenterSize(center:S2LatLng, size:S2LatLng) {\n    return S2LatLngRect.fromPoint(center).expanded(size.mul(0.5));\n  }\n\n  /** Convenience method to construct a rectangle containing a single point. */\n  public static  fromPoint(p:S2LatLng):S2LatLngRect {\n    // assert (p.isValid());\n    return S2LatLngRect.fromLatLng(p, p);\n  }\n\n  /**\n   * Convenience method to construct the minimal bounding rectangle containing\n   * the two given points. This is equivalent to starting with an empty\n   * rectangle and calling AddPoint() twice. Note that it is different than the\n   * S2LatLngRect(lo, hi) constructor, where the first point is always used as\n   * the lower-left corner of the resulting rectangle.\n   */\n  public static fromPointPair(p1:S2LatLng, p2:S2LatLng):S2LatLngRect {\n    // assert (p1.isValid() && p2.isValid());\n    return new S2LatLngRect(R1Interval.fromPointPair(p1.latRadians, p2\n        .latRadians), S1Interval.fromPointPair(p1.lngRadians, p2.lngRadians));\n  }\n\n  /**\n   * Return a latitude-longitude rectangle that contains the edge from \"a\" to\n   * \"b\". Both points must be unit-length. Note that the bounding rectangle of\n   * an edge can be larger than the bounding rectangle of its endpoints.\n   */\n  public static  fromEdge(a:S2Point, b:S2Point):S2LatLngRect {\n    // assert (S2.isUnitLength(a) && S2.isUnitLength(b));\n    let r = S2LatLngRect.fromPointPair(S2LatLng.fromPoint(a), S2LatLng.fromPoint(b));\n\n    // Check whether the min/max latitude occurs in the edge interior.\n    // We find the normal to the plane containing AB, and then a vector \"dir\" in\n    // this plane that also passes through the equator. We use RobustCrossProd\n    // to ensure that the edge normal is accurate even when the two points are\n    // very close together.\n    const ab = S2.robustCrossProd(a, b);\n    const dir = S2Point.crossProd(ab, new S2Point(0, 0, 1));\n    const da = dir.dotProd(a);\n    const db = dir.dotProd(b);\n    if (da.times(db).gte(0)) {\n      // Minimum and maximum latitude are attained at the vertices.\n      return r;\n    }\n    // Minimum/maximum latitude occurs in the edge interior. This affects the\n    // latitude bounds but not the longitude bounds.\n    const absLat = decimal.Decimal.acos(ab.z.dividedBy(ab.norm()).abs());\n    if (da.lt(0)) {\n      return new S2LatLngRect(new R1Interval(r.lat.lo, absLat), r.lng);\n    } else {\n      return new S2LatLngRect(new R1Interval(-absLat, r.lat.hi), r.lng);\n    }\n  }\n\n  /**\n   * Return true if the rectangle is valid, which essentially just means that\n   * the latitude bounds do not exceed Pi/2 in absolute value and the longitude\n   * bounds do not exceed Pi in absolute value.\n   *\n   */\n  public isValid():boolean {\n    // The lat/lng ranges must either be both empty or both non-empty.\n    return (this.lat.lo.abs().lte(S2.M_PI_2) && this.lat.hi.abs().lte(S2.M_PI_2)\n    && this.lng.isValid() && this.lat.isEmpty() == this.lng.isEmpty());\n  }\n\n  public lo():S2LatLng {\n    return new S2LatLng(this.lat.lo, this.lng.lo);\n  }\n\n  public hi():S2LatLng {\n    return new S2LatLng(this.lat.hi, this.lng.hi);\n  }\n\n  /**\n   * Return true if the rectangle is empty, i.e. it contains no points at all.\n   */\n  public isEmpty():boolean {\n    return this.lat.isEmpty();\n  }\n\n// Return true if the rectangle is full, i.e. it contains all points.\n  public isFull():boolean {\n    // console.log(this.lat.toString());\n    // console.log(S2LatLngRect.fullLat().toString());\n    return this.lat.equals(S2LatLngRect.fullLat()) && this.lng.isFull();\n  }\n\n  /**\n   * Return true if lng_.lo() > lng_.hi(), i.e. the rectangle crosses the 180\n   * degree latitude line.\n   */\n  public  isInverted():boolean {\n    return this.lng.isInverted();\n  }\n\n  /** Return the k-th vertex of the rectangle (k = 0,1,2,3) in CCW order. */\n  public  getVertex(k:number):S2LatLng {\n    // Return the points in CCW order (SW, SE, NE, NW).\n    switch (k) {\n      case 0:\n        return this.lo();\n      case 1:\n        return new S2LatLng(this.lat.lo, this.lng.hi);\n      case 2:\n        return this.hi();\n      case 3:\n        return new S2LatLng(this.lat.hi, this.lng.lo);\n      default:\n        throw new Error(\"Invalid vertex index.\");\n    }\n  }\n\n  /**\n   * Return the center of the rectangle in latitude-longitude space (in general\n   * this is not the center of the region on the sphere).\n   */\n  public  getCenter():S2LatLng {\n    return new S2LatLng(this.lat.getCenter(), this.lng.getCenter());\n  }\n\n  /**\n   * Return the minimum distance (measured along the surface of the sphere)\n   * from a given point to the rectangle (both its boundary and its interior).\n   * The latLng must be valid.\n   */\n  public getDistanceLL(p:S2LatLng):S1Angle {\n    // The algorithm here is the same as in getDistance(S2LagLngRect), only\n    // with simplified calculations.\n    const a = this;\n    if (a.isEmpty()) {\n      throw new Error();\n    }\n    if (!p.isValid()) {\n      throw new Error('point is not valid');\n    }\n\n\n    if (a.lng.contains(p.lngRadians)) {\n      return new S1Angle(\n          decimal.Decimal.max(\n              0.0,\n              decimal.Decimal.max(\n                  p.latRadians.minus(a.lat.hi),\n                  a.lat.lo.minus(p.latRadians)\n              )\n          )\n      );\n    }\n\n    let interval = new S1Interval(a.lng.hi, a.lng.complement().getCenter());\n    let aLng = a.lng.lo;\n    if (interval.contains(p.lngRadians)) {\n      aLng = a.lng.hi;\n    }\n\n    const lo = new S2LatLng(a.lat.lo, aLng).toPoint();\n    const hi = new S2LatLng(a.lat.hi, aLng).toPoint();\n    let loCrossHi = new S2LatLng(0, aLng.minus(S2.M_PI_2)).normalized().toPoint();\n    return S2EdgeUtil.getDistance(p.toPoint(), lo, hi, loCrossHi);\n  }\n\n  /**\n   * Return the minimum distance (measured along the surface of the sphere) to\n   * the given S2LatLngRect. Both S2LatLngRects must be non-empty.\n   */\n  public  getDistanceLLR(other:S2LatLngRect):S1Angle {\n    const a = this;\n    const b = other;\n    if (a.isEmpty()) {\n      throw new Error();\n    }\n    if (b.isEmpty()) {\n      throw new Error();\n    }\n\n\n    // First, handle the trivial cases where the longitude intervals overlap.\n    if (a.lng.intersects(b.lng)) {\n      if (a.lat.intersects(b.lat)) {\n        return new S1Angle(0);  // Intersection between a and b.\n      }\n\n      // We found an overlap in the longitude interval, but not in the latitude\n      // interval. This means the shortest path travels along some line of\n      // longitude connecting the high-latitude of the lower rect with the\n      // low-latitude of the higher rect.\n      let lo, hi;\n      if (a.lat.lo.gt(b.lat.hi)) {\n        lo = b.lat.hi;\n        hi = a.lat.lo;\n      } else {\n        lo = a.lat.hi;\n        hi = b.lat.lo;\n      }\n      return new S1Angle(hi.radians().minus(lo.radians()));\n    }\n\n    // The longitude intervals don't overlap. In this case, the closest points\n    // occur somewhere on the pair of longitudinal edges which are nearest in\n    // longitude-space.\n    let aLng, bLng;\n    const loHi = S1Interval.fromPointPair(a.lng.lo, b.lng.hi);\n    const hiLo = S1Interval.fromPointPair(a.lng.hi, b.lng.lo);\n    if (loHi.getLength().lt(hiLo.getLength())) {\n      aLng = a.lng.lo;\n      bLng = b.lng.hi;\n    } else {\n      aLng = a.lng.hi;\n      bLng = b.lng.lo;\n    }\n\n    // The shortest distance between the two longitudinal segments will include\n    // at least one segment endpoint. We could probably narrow this down further\n    // to a single point-edge distance by comparing the relative latitudes of the\n    // endpoints, but for the sake of clarity, we'll do all four point-edge\n    // distance tests.\n    let aLo = new S2LatLng(a.lat.lo, aLng).toPoint();\n    let aHi = new S2LatLng(a.lat.hi, aLng).toPoint();\n    let aLoCrossHi = new S2LatLng(0, aLng.radians().minus(S2.M_PI_2)).normalized().toPoint();\n    let bLo = new S2LatLng(b.lat.lo, bLng).toPoint();\n    let bHi = new S2LatLng(b.lat.hi, bLng).toPoint();\n    let bLoCrossHi = new S2LatLng(0, bLng.radians().minus(S2.M_PI_2)).normalized().toPoint();\n\n    return S1Angle.min(S2EdgeUtil.getDistance(aLo, bLo, bHi, bLoCrossHi),\n        S1Angle.min(S2EdgeUtil.getDistance(aHi, bLo, bHi, bLoCrossHi),\n            S1Angle.min(S2EdgeUtil.getDistance(bLo, aLo, aHi, aLoCrossHi),\n                S2EdgeUtil.getDistance(bHi, aLo, aHi, aLoCrossHi))));\n  }\n\n  /**\n   * Return the width and height of this rectangle in latitude-longitude space.\n   * Empty rectangles have a negative width and height.\n   */\n  public  getSize():S2LatLng {\n    return new S2LatLng(this.lat.getLength(), this.lng.getLength());\n  }\n\n  /**\n   * More efficient version of Contains() that accepts a S2LatLng rather than an\n   * S2Point.\n   */\n  public containsLL(ll:S2LatLng):boolean {\n    // assert (ll.isValid());\n    return (this.lat.contains(ll.latRadians) && this.lng.contains(ll.lngRadians));\n\n  }\n\n  /**\n   * Return true if and only if the given point is contained in the interior of\n   * the region (i.e. the region excluding its boundary). The point 'p' does not\n   * need to be normalized.\n   */\n  public interiorContainsP(p:S2Point):boolean {\n    return this.interiorContainsLL(S2LatLng.fromPoint(p));\n  }\n\n  /**\n   * More efficient version of InteriorContains() that accepts a S2LatLng rather\n   * than an S2Point.\n   */\n  public interiorContainsLL(ll:S2LatLng):boolean {\n    // assert (ll.isValid());\n    return (this.lat.interiorContains(ll.latRadians) && this.lng\n        .interiorContains(ll.lngRadians));\n  }\n\n  /**\n   * Return true if and only if the rectangle contains the given other\n   * rectangle.\n   */\n  public containsLLR(other:S2LatLngRect):boolean {\n    return this.lat.containsI(other.lat) && this.lng.containsI(other.lng);\n  }\n\n  /**\n   * Return true if and only if the interior of this rectangle contains all\n   * points of the given other rectangle (including its boundary).\n   */\n  public interiorContainsLLR(other:S2LatLngRect):boolean {\n    return (this.lat.interiorContainsI(other.lat) && this.lng\n        .interiorContainsI(other.lng));\n  }\n\n  /** Return true if this rectangle and the given other rectangle have any\n   points in common. */\n  public intersectsLLR(other:S2LatLngRect):boolean {\n    return this.lat.intersects(other.lat) && this.lng.intersects(other.lng);\n  }\n\n  /**\n   * Returns true if this rectangle intersects the given cell. (This is an exact\n   * test and may be fairly expensive, see also MayIntersect below.)\n   */\n  public intersects(cell:S2Cell):boolean {\n    // First we eliminate the cases where one region completely contains the\n    // other. Once these are disposed of, then the regions will intersect\n    // if and only if their boundaries intersect.\n\n    if (this.isEmpty()) {\n      return false;\n    }\n    if (this.containsP(cell.getCenter())) {\n      return true;\n    }\n    if (cell.contains(this.getCenter().toPoint())) {\n      return true;\n    }\n\n    // Quick rejection test (not required for correctness).\n    if (!this.intersectsLLR(cell.getRectBound())) {\n      return false;\n    }\n\n    // Now check whether the boundaries intersect. Unfortunately, a\n    // latitude-longitude rectangle does not have straight edges -- two edges\n    // are curved, and at least one of them is concave.\n\n    // Precompute the cell vertices as points and latitude-longitudes.\n    const cellV = new Array<S2Point>(4);\n    const cellLl = new Array<S2LatLng>(4);\n    for (let i = 0; i < 4; ++i) {\n      cellV[i] = cell.getVertex(i); // Must be normalized.\n      cellLl[i] = S2LatLng.fromPoint(cellV[i]);\n      if (this.containsLL(cellLl[i])) {\n        return true; // Quick acceptance test.\n      }\n    }\n\n    for (let i = 0; i < 4; ++i) {\n      const edgeLng = S1Interval.fromPointPair(\n          cellLl[i].lngRadians, cellLl[(i + 1) & 3].lngRadians);\n      if (!this.lng.intersects(edgeLng)) {\n        continue;\n      }\n\n      const a = cellV[i];\n      const b = cellV[(i + 1) & 3];\n      if (edgeLng.contains(this.lng.lo)) {\n        if (S2LatLngRect.intersectsLngEdge(a, b, this.lat, this.lng.lo)) {\n          return true;\n        }\n      }\n      if (edgeLng.contains(this.lng.hi)) {\n        if (S2LatLngRect.intersectsLngEdge(a, b, this.lat, this.lng.hi)) {\n          return true;\n        }\n      }\n      if (S2LatLngRect.intersectsLatEdge(a, b, this.lat.lo, this.lng)) {\n        return true;\n      }\n      if (S2LatLngRect.intersectsLatEdge(a, b, this.lat.hi, this.lng)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return true if and only if the interior of this rectangle intersects any\n   * point (including the boundary) of the given other rectangle.\n   */\n  public  interiorIntersects(other:S2LatLngRect):boolean {\n    return (this.lat.interiorIntersects(other.lat) && this.lng\n        .interiorIntersects(other.lng));\n  }\n\n  public addPoint(p:S2Point):S2LatLngRect {\n    return this.addPointLL(S2LatLng.fromPoint(p));\n  }\n\n// Increase the size of the bounding rectangle to include the given point.\n// The rectangle is expanded by the minimum amount possible.\n  public  addPointLL(ll:S2LatLng):S2LatLngRect {\n    const newLat = this.lat.addPoint(ll.latRadians);\n    const newLng = this.lng.addPoint(ll.lngRadians);\n    return new S2LatLngRect(newLat, newLng);\n  }\n\n  /**\n   * Return a rectangle that contains all points whose latitude distance from\n   * this rectangle is at most margin.lat, and whose longitude distance from\n   * this rectangle is at most margin.lng. In particular, latitudes are\n   * clamped while longitudes are wrapped. Note that any expansion of an empty\n   * interval remains empty, and both components of the given margin must be\n   * non-negative.\n   *\n   * NOTE: If you are trying to grow a rectangle by a certain *distance* on the\n   * sphere (e.g. 5km), use the ConvolveWithCap() method instead.\n   */\n  public  expanded(margin:S2LatLng):S2LatLngRect {\n    // assert (margin.latRadians >= 0 && margin.lngRadians >= 0);\n    if (this.isEmpty()) {\n      return this;\n    }\n    return new S2LatLngRect(\n        this.lat\n            .expanded(margin.latRadians)\n            .intersection(\n                S2LatLngRect.fullLat()\n            ),\n        this.lng.expanded(margin.lngRadians)\n    );\n  }\n\n  /**\n   * Return the smallest rectangle containing the union of this rectangle and\n   * the given rectangle.\n   */\n  public union(other:S2LatLngRect):S2LatLngRect {\n    return new S2LatLngRect(this.lat.union(other.lat), this.lng.union(other.lng));\n  }\n\n  /**\n   * Return the smallest rectangle containing the intersection of this rectangle\n   * and the given rectangle. Note that the region of intersection may consist\n   * of two disjoint rectangles, in which case a single rectangle spanning both\n   * of them is returned.\n   */\n  public  intersection(other:S2LatLngRect):S2LatLngRect {\n    const intersectLat = this.lat.intersection(other.lat);\n    const intersectLng = this.lng.intersection(other.lng);\n    if (intersectLat.isEmpty() || intersectLng.isEmpty()) {\n      // The lat/lng ranges must either be both empty or both non-empty.\n      return S2LatLngRect.empty();\n    }\n    return new S2LatLngRect(intersectLat, intersectLng);\n  }\n\n//\n// /**\n//  * Return a rectangle that contains the convolution of this rectangle with a\n//  * cap of the given angle. This expands the rectangle by a fixed distance (as\n//  * opposed to growing the rectangle in latitude-longitude space). The returned\n//  * rectangle includes all points whose minimum distance to the original\n//  * rectangle is at most the given angle.\n//  */\n// public S2LatLngRect convolveWithCap(/*S1Angle*/ angle) {\n//   // The most straightforward approach is to build a cap centered on each\n//   // vertex and take the union of all the bounding rectangles (including the\n//   // original rectangle; this is necessary for very large rectangles).\n//\n//   // Optimization: convert the angle to a height exactly once.\n//   S2Cap cap = S2Cap.fromAxisAngle(new S2Point(1, 0, 0), angle);\n//\n//   S2LatLngRect r = this;\n//   for (int k = 0; k < 4; ++k) {\n//     S2Cap vertexCap = S2Cap.fromAxisHeight(getVertex(k).toPoint(), cap\n//         .height());\n//     r = r.union(vertexCap.getRectBound());\n//   }\n//   return r;\n// }\n\n  /** Return the surface area of this rectangle on the unit sphere. */\n  public area():decimal.Decimal {\n    if (this.isEmpty()) {\n      return S2.toDecimal(0);\n    }\n\n    // This is the size difference of the two spherical caps, multiplied by\n    // the longitude ratio.\n    //TODO: check if this.lat.hi & this.lat.lo is radians. \n    return this.lng.getLength().times(decimal.Decimal.sin(this.lat.hi).minus(decimal.Decimal.sin(this.lat.lo)).abs());\n  }\n\n  /** Return true if two rectangles contains the same set of points. */\n\n  public equals(that:any):boolean {\n    if (!(that instanceof S2LatLngRect)) {\n      return false;\n    }\n    return this.lat.equals(that.lat) && this.lng.equals(that.lng);\n  }\n\n  /**\n   * Return true if the latitude and longitude intervals of the two rectangles\n   * are the same up to the given tolerance (see r1interval.h and s1interval.h\n   * for details).\n   */\n  public approxEquals(other:S2LatLngRect, maxError:number = 1e-15):boolean {\n    return (this.lat.approxEquals(other.lat, maxError) && this.lng.approxEquals(\n        other.lng, maxError));\n  }\n\n// //////////////////////////////////////////////////////////////////////\n// S2Region interface (see {@code S2Region} for details):\n\n\n  public clone():S2Region {\n    return new S2LatLngRect(this.lat, this.lng);\n  }\n\n\n  public getCapBound():S2Cap {\n    // We consider two possible bounding caps, one whose axis passes\n    // through the center of the lat-long rectangle and one whose axis\n    // is the north or south pole. We return the smaller of the two caps.\n\n    if (this.isEmpty()) {\n      return S2Cap.empty();\n    }\n\n    let poleZ, poleAngle;\n    if (this.lat.lo.plus(this.lat.hi).lt(0)) {\n      // South pole axis yields smaller cap.\n      poleZ = -1;\n      poleAngle = this.lat.hi.plus(S2.M_PI_2);\n    } else {\n      poleZ = 1;\n      poleAngle = this.lat.lo.neg().plus(S2.M_PI_2);\n    }\n\n    const poleCap = S2Cap.fromAxisAngle(new S2Point(0, 0, poleZ), new S1Angle(poleAngle));\n\n    // For bounding rectangles that span 180 degrees or less in longitude, the\n    // maximum cap size is achieved at one of the rectangle vertices. For\n    // rectangles that are larger than 180 degrees, we punt and always return a\n    // bounding cap centered at one of the two poles.\n    const lngSpan = this.lng.hi.minus(this.lng.lo);\n    if (S2.IEEEremainder(lngSpan, 2 * S2.M_PI).gte(0)) {\n      if (lngSpan.lt(2 * S2.M_PI)) {\n        let midCap = S2Cap.fromAxisAngle(this.getCenter().toPoint(), new S1Angle(0));\n        for (let k = 0; k < 4; ++k) {\n          midCap = midCap.addPoint(this.getVertex(k).toPoint());\n        }\n        if (midCap.height.lt(poleCap.height)) {\n          return midCap;\n        }\n      }\n    }\n    return poleCap;\n  }\n\n\n  public  getRectBound():S2LatLngRect {\n    return this;\n  }\n\n\n  public /*boolean*/ containsC(cell:S2Cell):boolean {\n    // A latitude-longitude rectangle contains a cell if and only if it contains\n    // the cell's bounding rectangle. (This is an exact test.)\n    return this.containsLLR(cell.getRectBound());\n  }\n\n  /**\n   * This test is cheap but is NOT exact. Use Intersects() if you want a more\n   * accurate and more expensive test. Note that when this method is used by an\n   * S2RegionCoverer, the accuracy isn't all that important since if a cell may\n   * intersect the region then it is subdivided, and the accuracy of this method\n   * goes up as the cells get smaller.\n   */\n\n  public /*boolean*/ mayIntersectC(cell:S2Cell):boolean {\n    // This test is cheap but is NOT exact (see s2latlngrect.h).\n    return this.intersectsLLR(cell.getRectBound());\n  }\n\n  /** The point 'p' does not need to be normalized. */\n  public /*boolean*/ containsP(p:S2Point):boolean {\n    return this.containsLL(S2LatLng.fromPoint(p));\n  }\n\n  /**\n   * Return true if the edge AB intersects the given edge of constant longitude.\n   */\n  private static /*boolean*/ intersectsLngEdge(a:S2Point, b:S2Point,\n                                               lat:R1Interval, lng:decimal.Decimal|number) {\n    // Return true if the segment AB intersects the given edge of constant\n    // longitude. The nice thing about edges of constant longitude is that\n    // they are straight lines on the sphere (geodesics).\n\n\n    return S2.simpleCrossing(a, b, new S2LatLng(lat.lo, lng)\n        .toPoint(), new S2LatLng(lat.hi, lng).toPoint());\n  }\n\n  /**\n   * Return true if the edge AB intersects the given edge of constant latitude.\n   */\n  private static /*boolean*/ intersectsLatEdge(a:S2Point, b:S2Point, lat:number|decimal.Decimal,\n                                               lng:S1Interval) {\n    // Return true if the segment AB intersects the given edge of constant\n    // latitude. Unfortunately, lines of constant latitude are curves on\n    // the sphere. They can intersect a straight edge in 0, 1, or 2 points.\n    // assert (S2.isUnitLength(a) && S2.isUnitLength(b));\n\n    // First, compute the normal to the plane AB that points vaguely north.\n    let z = S2Point.normalize(S2.robustCrossProd(a, b));\n    if (z.z.lt(0)) {\n      z = S2Point.neg(z);\n    }\n\n    // Extend this to an orthonormal frame (x,y,z) where x is the direction\n    // where the great circle through AB achieves its maximium latitude.\n    const y = S2Point.normalize(S2.robustCrossProd(z, new S2Point(0, 0, 1)));\n    const x = S2Point.crossProd(y, z);\n    // assert (S2.isUnitLength(x) && x.z >= 0);\n\n    // Compute the angle \"theta\" from the x-axis (in the x-y plane defined\n    // above) where the great circle intersects the given line of latitude.\n    let sinLat = decimal.Decimal.sin(lat);\n    if (sinLat.abs().gte(x.z)) {\n      return false; // The great circle does not reach the given latitude.\n    }\n    // assert (x.z > 0);\n    const cosTheta = sinLat.dividedBy(x.z);\n    const sinTheta = cosTheta.pow(2).neg().plus(1).sqrt(); // Math.sqrt(1 - cosTheta * cosTheta);\n    const theta = decimal.Decimal.atan2(sinTheta, cosTheta);\n    // Math.atan2(sinTheta, cosTheta);\n\n    // The candidate intersection points are located +/- theta in the x-y\n    // plane. For an intersection to be valid, we need to check that the\n    // intersection point is contained in the interior of the edge AB and\n    // also that it is contained within the given longitude interval \"lng\".\n\n    // Compute the range of theta values spanned by the edge AB.\n    const abTheta = S1Interval.fromPointPair(decimal.Decimal.atan2(\n        a.dotProd(y), a.dotProd(x)), decimal.Decimal.atan2(b.dotProd(y), b.dotProd(x)));\n\n    if (abTheta.contains(theta)) {\n      // Check if the intersection point is also in the given \"lng\" interval.\n      const isect = S2Point.add(S2Point.mul(x, cosTheta), S2Point.mul(y,\n          sinTheta));\n      if (lng.contains(decimal.Decimal.atan2(isect.y, isect.x))) {\n        return true;\n      }\n    }\n    if (abTheta.contains(theta.neg())) {\n      // Check if the intersection point is also in the given \"lng\" interval.\n      const intersection = S2Point.sub(S2Point.mul(x, cosTheta), S2Point.mul(y, sinTheta));\n      if (lng.contains(decimal.Decimal.atan2(intersection.y, intersection.x))) {\n        return true;\n      }\n    }\n    return false;\n\n  }\n\n  public allVertex() {\n    return [\n      this.getVertex(0),\n      this.getVertex(1),\n      this.getVertex(2),\n      this.getVertex(3)\n    ]\n  }\n\n  public toGEOJSON():any {\n    return {\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates: [this.allVertex().concat(this.getVertex(0)).map(v => [parseFloat(v.lngDegrees.toFixed(5)), parseFloat(v.latDegrees.toFixed(5))])],\n      },\n      properties: {}\n\n    }\n  }\n\n  public toString():string {\n    return \"[Lo=\" + this.lo().toString() + \", Hi=\" + this.hi().toString() + \"]\";\n  }\n\n\n}\n","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport {S2Region} from \"./S2Region\";\nimport {S2} from \"./S2\";\nimport {S2Point} from \"./S2Point\";\nimport {S1Angle} from \"./S1Angle\";\nimport {S2LatLngRect} from \"./S2LatLngRect\";\nimport {S2LatLng} from \"./S2LatLng\";\nimport {R1Interval} from \"./R1Interval\";\nimport {S1Interval} from \"./S1Interval\";\nimport {S2Cell} from \"./S2Cell\";\nimport Long from 'long';\nimport * as decimal from 'decimal.js';\n/**\n * This class represents a spherical cap, i.e. a portion of a sphere cut off by\n * a plane. The cap is defined by its axis and height. This representation has\n * good numerical accuracy for very small caps (unlike the (axis,\n * min-distance-from-origin) representation), and is also efficient for\n * containment tests (unlike the (axis, angle) representation).\n *\n * Here are some useful relationships between the cap height (h), the cap\n * opening angle (theta), the maximum chord length from the cap's center (d),\n * and the radius of cap's base (a). All formulas assume a unit radius.\n *\n * h = 1 - cos(theta) = 2 sin^2(theta/2) d^2 = 2 h = a^2 + h^2\n *\n */\nexport class S2Cap implements S2Region {\n\n\n  /**\n   * Multiply a positive number by this constant to ensure that the result of a\n   * floating point operation is at least as large as the true\n   * infinite-precision result.\n   */\n  private static ROUND_UP = S2.toDecimal(1).dividedBy(new Long(1).shiftLeft(52).toString()).plus(1);\n\n  public axis:S2Point;\n  public height:decimal.Decimal;\n\n  /**\n   * Create a cap given its axis and the cap height, i.e. the maximum projected\n   * distance along the cap axis from the cap center. 'axis' should be a\n   * unit-length vector.\n   */\n  constructor(axis:S2Point, _height:number|decimal.Decimal) {\n    this.axis = axis;\n    this.height = S2.toDecimal(_height);\n    // assert (isValid());\n  }\n\n  /**\n   * Create a cap given its axis and the cap opening angle, i.e. maximum angle\n   * between the axis and a point on the cap. 'axis' should be a unit-length\n   * vector, and 'angle' should be between 0 and 180 degrees.\n   */\n  public static fromAxisAngle(axis:S2Point, angle:S1Angle):S2Cap {\n    // The height of the cap can be computed as 1-cos(angle), but this isn't\n    // very accurate for angles close to zero (where cos(angle) is almost 1).\n    // Computing it as 2*(sin(angle/2)**2) gives much better precision.\n\n    // assert (S2.isUnitLength(axis));\n    const d = angle.radians.times(0.5).sin();\n    // ecimal.sin(0.5 * angle.radians.times(0.5));\n    return new S2Cap(axis, d.pow(2).times(2));\n\n  }\n\n  /**\n   * Create a cap given its axis and its area in steradians. 'axis' should be a\n   * unit-length vector, and 'area' should be between 0 and 4 * M_PI.\n   */\n  public static fromAxisArea(axis:S2Point, _area:number|decimal.Decimal):S2Cap {\n    const area = S2.toDecimal(_area);\n    // assert (S2.isUnitLength(axis));\n    return new S2Cap(axis, area.dividedBy(S2.toDecimal(2).times(S2.M_PI)));\n  }\n\n  /** Return an empty cap, i.e. a cap that contains no points. */\n  public static empty():S2Cap {\n    return new S2Cap(new S2Point(1, 0, 0), -1);\n  }\n\n  /** Return a full cap, i.e. a cap that contains all points. */\n  public static full():S2Cap {\n    return new S2Cap(new S2Point(1, 0, 0), 2);\n  }\n  getCapBound():S2Cap {\n    return this;\n  }\n\n  public area():decimal.Decimal {\n    return decimal.Decimal.max(\n        0,\n        this.height\n    )\n        .times(S2.M_PI)\n        .times(2);\n    // return 2 * S2.M_PI * Math.max(0.0, this.height);\n  }\n\n  /**\n   * Return the cap opening angle in radians, or a negative number for empty\n   * caps.\n   */\n  public  angle():S1Angle {\n    // This could also be computed as acos(1 - height_), but the following\n    // formula is much more accurate when the cap height is small. It\n    // follows from the relationship h = 1 - cos(theta) = 2 sin^2(theta/2).\n    if (this.isEmpty()) {\n      return new S1Angle(-1);\n    }\n    return new S1Angle(\n        decimal.Decimal.asin(\n            this.height.times(0.5).sqrt()\n        )\n            .times(2)\n    );\n  }\n\n  /**\n   * We allow negative heights (to represent empty caps) but not heights greater\n   * than 2.\n   */\n  public isValid():boolean {\n    return S2.isUnitLength(this.axis) && this.height.lte(2);\n  }\n\n  /** Return true if the cap is empty, i.e. it contains no points. */\n  public  isEmpty():boolean {\n    return this.height.lt(0);\n  }\n\n  /** Return true if the cap is full, i.e. it contains all points. */\n  public isFull():boolean {\n    return this.height.gte(2);\n  }\n\n  /**\n   * Return the complement of the interior of the cap. A cap and its complement\n   * have the same boundary but do not share any interior points. The complement\n   * operator is not a bijection, since the complement of a singleton cap\n   * (containing a single point) is the same as the complement of an empty cap.\n   */\n  public complement():S2Cap {\n    // The complement of a full cap is an empty cap, not a singleton.\n    // Also make sure that the complement of an empty cap has height 2.\n    let cHeight = this.isFull() ? -1 : decimal.Decimal.max(this.height, 0).neg().plus(2);\n    return new S2Cap(S2Point.neg(this.axis), cHeight);\n  }\n\n  /**\n   * Return true if and only if this cap contains the given other cap (in a set\n   * containment sense, e.g. every cap contains the empty cap).\n   */\n  public  containsCap(other:S2Cap):boolean {\n    if (this.isFull() || other.isEmpty()) {\n      return true;\n    }\n    return this.angle().radians.gte(this.axis.angle(other.axis).plus(other.angle().radians));\n  }\n\n  /**\n   * Return true if and only if the interior of this cap intersects the given\n   * other cap. (This relationship is not symmetric, since only the interior of\n   * this cap is used.)\n   */\n  public interiorIntersects(other:S2Cap):boolean {\n    // Interior(X) intersects Y if and only if Complement(Interior(X))\n    // does not contain Y.\n    return !this.complement().containsCap(other);\n  }\n\n  /**\n   * Return true if and only if the given point is contained in the interior of\n   * the region (i.e. the region excluding its boundary). 'p' should be a\n   * unit-length vector.\n   */\n  public  interiorContains(p:S2Point):boolean {\n    // assert (S2.isUnitLength(p));\n    return this.isFull() || S2Point.sub(this.axis, p).norm2().lt(this.height.times(2));\n  }\n\n  /**\n   * Increase the cap height if necessary to include the given point. If the cap\n   * is empty the axis is set to the given point, but otherwise it is left\n   * unchanged. 'p' should be a unit-length vector.\n   */\n  public addPoint(p:S2Point):S2Cap {\n    // Compute the squared chord length, then convert it into a height.\n    // assert (S2.isUnitLength(p));\n    if (this.isEmpty()) {\n      return new S2Cap(p, 0);\n    } else {\n      // To make sure that the resulting cap actually includes this point,\n      // we need to round up the distance calculation. That is, after\n      // calling cap.AddPoint(p), cap.Contains(p) should be true.\n      let dist2 = S2Point.sub(this.axis, p).norm2();\n      let newHeight = decimal.Decimal.max(this.height, S2Cap.ROUND_UP.times(0.5).times(dist2));\n      return new S2Cap(this.axis, newHeight);\n    }\n  }\n\n// Increase the cap height if necessary to include \"other\". If the current\n// cap is empty it is set to the given other cap.\n  public addCap(other:S2Cap):S2Cap {\n    if (this.isEmpty()) {\n      return new S2Cap(other.axis, other.height);\n    } else {\n      // See comments for FromAxisAngle() and AddPoint(). This could be\n      // optimized by doing the calculation in terms of cap heights rather\n      // than cap opening angles.\n      let angle = this.axis.angle(other.axis).plus(other.angle().radians);\n      if (angle.gte(S2.M_PI)) {\n        return new S2Cap(this.axis, 2); //Full cap\n      } else {\n        let d = angle.times(0.5).sin();\n        let newHeight = decimal.Decimal.max(this.height, S2Cap.ROUND_UP.times(2).times(d.pow(2)));\n        return new S2Cap(this.axis, newHeight);\n      }\n    }\n  }\n\n// //////////////////////////////////////////////////////////////////////\n// S2Region interface (see {@code S2Region} for details):\n  public  getRectBound():S2LatLngRect {\n    if (this.isEmpty()) {\n      return S2LatLngRect.empty();\n    }\n\n    // Convert the axis to a (lat,lng) pair, and compute the cap angle.\n    const axisLatLng = S2LatLng.fromPoint(this.axis);\n    const capAngle = this.angle().radians;\n\n    let allLongitudes = false;\n    const lat:decimal.Decimal[] = Array(2);\n    const lng:decimal.Decimal[] = Array(2);\n\n    lng[0] = S2.toDecimal(-S2.M_PI);\n    lng[1] = S2.toDecimal(S2.M_PI);\n\n    // Check whether cap includes the south pole.\n    lat[0] = axisLatLng.latRadians.minus(capAngle);\n    if (lat[0].lte(-S2.M_PI_2)) {\n      lat[0] = S2.toDecimal(-S2.M_PI_2);\n      allLongitudes = true;\n    }\n    // Check whether cap includes the north pole.\n    lat[1] = axisLatLng.latRadians.plus(capAngle);\n    if (lat[1].gte(S2.M_PI_2)) {\n      lat[1] = S2.toDecimal(S2.M_PI_2);\n      allLongitudes = true;\n    }\n    if (!allLongitudes) {\n      // Compute the range of longitudes covered by the cap. We use the law\n      // of sines for spherical triangles. Consider the triangle ABC where\n      // A is the north pole, B is the center of the cap, and C is the point\n      // of tangency between the cap boundary and a line of longitude. Then\n      // C is a right angle, and letting a,b,c denote the sides opposite A,B,C,\n      // we have sin(a)/sin(A) = sin(c)/sin(C), or sin(A) = sin(a)/sin(c).\n      // Here \"a\" is the cap angle, and \"c\" is the colatitude (90 degrees\n      // minus the latitude). This formula also works for negative latitudes.\n      //\n      // The formula for sin(a) follows from the relationship h = 1 - cos(a).\n\n      // double sinA = Math.sqrt(this.height * (2 - this.height));\n      // double sinC = Math.cos(axisLatLng.lat().radians());\n      const sinA = this.height.times(this.height.neg().plus(2)).sqrt();\n      const sinC = axisLatLng.latRadians.cos();\n      if (sinA.lte(sinC)) {\n        const angleA = decimal.Decimal.asin(sinA.dividedBy(sinC));\n        lng[0] = S2.IEEEremainder(axisLatLng.lngRadians.minus(angleA),\n            2 * S2.M_PI);\n        lng[1] = S2.IEEEremainder(axisLatLng.lngRadians.plus(angleA),\n            2 * S2.M_PI);\n      }\n    }\n    return new S2LatLngRect(\n        new R1Interval(lat[0], lat[1]),\n        new S1Interval(lng[0], lng[1])\n    );\n  }\n\n\n  public containsC(cell:S2Cell):boolean {\n    // If the cap does not contain all cell vertices, return false.\n    // We check the vertices before taking the Complement() because we can't\n    // accurately represent the complement of a very small cap (a height\n    // of 2-epsilon is rounded off to 2).\n    const vertices:S2Point[] = new Array(4);\n    for (let k = 0; k < 4; ++k) {\n      vertices[k] = cell.getVertex(k);\n      if (!this.contains(vertices[k])) {\n        return false;\n      }\n    }\n    // Otherwise, return true if the complement of the cap does not intersect\n    // the cell. (This test is slightly conservative, because technically we\n    // want Complement().InteriorIntersects() here.)\n    return !this.complement().intersects(cell, vertices);\n  }\n\n  // public mayIntersectC(cell:S2Cell):boolean {\n  //   const toRet = this._mayIntersectC(cell);\n  //   console.log(\"intersects? \",toRet, cell.id.pos().toString(16), cell.level);\n  //   return toRet;\n  // }\n  public  mayIntersectC(cell:S2Cell):boolean {\n    // If the cap contains any cell vertex, return true.\n    const vertices:S2Point[] = new Array(4);\n    for (let k = 0; k < 4; ++k) {\n      vertices[k] = cell.getVertex(k);\n      if (this.contains(vertices[k])) {\n        return true;\n      }\n    }\n    return this.intersects(cell, vertices);\n  }\n\n  /**\n   * Return true if the cap intersects 'cell', given that the cap vertices have\n   * alrady been checked.\n   */\n  public intersects(cell:S2Cell, vertices:S2Point[]):boolean {\n    // Return true if this cap intersects any point of 'cell' excluding its\n    // vertices (which are assumed to already have been checked).\n\n    // If the cap is a hemisphere or larger, the cell and the complement of the\n    // cap are both convex. Therefore since no vertex of the cell is contained,\n    // no other interior point of the cell is contained either.\n    if (this.height.gte(1)) {\n      return false;\n    }\n\n    // We need to check for empty caps due to the axis check just below.\n    if (this.isEmpty()) {\n      return false;\n    }\n\n    // Optimization: return true if the cell contains the cap axis. (This\n    // allows half of the edge checks below to be skipped.)\n    if (cell.contains(this.axis)) {\n      return true;\n    }\n\n    // At this point we know that the cell does not contain the cap axis,\n    // and the cap does not contain any cell vertex. The only way that they\n    // can intersect is if the cap intersects the interior of some edge.\n\n    const sin2Angle = this.height.times(this.height.neg().plus(2)); // sin^2(capAngle)\n    // if (cell.id.pos().toString(16) === '77c040000000000') {\n    //   console.log(\"DIOCAN\");\n    // }\n    for (let k = 0; k < 4; ++k) {\n      let edge = cell.getEdgeRaw(k);\n      let dot = this.axis.dotProd(edge);\n      if (dot.gt(0)) {\n        // The axis is in the interior half-space defined by the edge. We don't\n        // need to consider these edges, since if the cap intersects this edge\n        // then it also intersects the edge on the opposite side of the cell\n        // (because we know the axis is not contained with the cell).\n        continue;\n      }\n      // The Norm2() factor is necessary because \"edge\" is not normalized.\n      if (dot.pow(2).gt(sin2Angle.times(edge.norm2()))) {\n        // if (cell.id.pos().toString(16) === '77c040000000000') {\n        //   console.log(\"DIOCaAN\", k, dot.toString(), sin2Angle.toString(), sin2Angle.times(edge.norm2()).toString());\n        // }\n        return false; // Entire cap is on the exterior side of this edge.\n      }\n      // Otherwise, the great circle containing this edge intersects\n      // the interior of the cap. We just need to check whether the point\n      // of closest approach occurs between the two edge endpoints.\n      const dir = S2Point.crossProd(edge, this.axis);\n      if (dir.dotProd(vertices[k]).lt(0)\n          && dir.dotProd(vertices[(k + 1) & 3]).gt(0)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public contains(p:S2Point):boolean {\n    // The point 'p' should be a unit-length vector.\n    // assert (S2.isUnitLength(p));\n    return S2Point.sub(this.axis, p).norm2().lte(this.height.times(2));\n\n  }\n\n//\n// /** Return true if two caps are identical. */\n// public equals(that:Object ):boolean  {\n//\n//   if (!(that instanceof S2Cap)) {\n//     return false;\n//   }\n//\n//   S2Cap other = (S2Cap) that;\n//   return (this.axis.equals(other.axis) && this.height == other.height)\n//       || (isEmpty() && other.isEmpty()) || (isFull() && other.isFull());\n//\n// }\n//\n// @Override\n// public int hashCode() {\n//   if (isFull()) {\n//     return 17;\n//   } else if (isEmpty()) {\n//     return 37;\n//   }\n//   int result = 17;\n//   result = 37 * result + this.axis.hashCode();\n//   long heightBits = Double.doubleToLongBits(this.height);\n//   result = 37 * result + (int) ((heightBits >>> 32) ^ heightBits);\n//   return result;\n// }\n\n// /////////////////////////////////////////////////////////////////////\n// The following static methods are convenience functions for assertions\n// and testing purposes only.\n\n  /**\n   * Return true if the cap axis and height differ by at most \"max_error\" from\n   * the given cap \"other\".\n   */\n  public approxEquals(other:S2Cap, maxError:number = 1e-14):boolean {\n    return (this.axis.aequal(other.axis, maxError) && this.height.minus(other.height).lte(maxError))\n        || (this.isEmpty() && other.height.lte(maxError))\n        || (other.isEmpty() && this.height.lte(maxError))\n        || (this.isFull() && other.height.gte(2 - maxError))\n        || (other.isFull() && this.height.gte(2 - maxError));\n  }\n\n  public toString():string {\n    return \"[Point = \" + this.axis.toString() + \" Height = \" + this.height.toString() + \"]\";\n  }\n  \n  public toGEOJSON(){\n    return this.getRectBound().toGEOJSON();\n  }\n}\n","export class MutableInteger {\n\n  constructor(public val:number) {\n  }\n}","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Long from 'long';\nimport {S2Point} from \"./S2Point\";\nimport {R2Vector} from \"./R2Vector\";\nimport {S2} from \"./S2\";\nimport {MutableInteger} from \"./MutableInteger\";\nimport {S2LatLng} from \"./S2LatLng\";\nimport * as decimal from 'decimal.js';\n\nlet parseHex = function parseHex(str) {\n  return Long.fromString(str, false, 16);\n};\n/**\n * An S2CellId is a 64-bit unsigned integer that uniquely identifies a cell in\n * the S2 cell decomposition. It has the following format:\n *\n * <pre>\n * id = [face][face_pos]\n * </pre>\n *\n * face: a 3-bit number (range 0..5) encoding the cube face.\n *\n * face_pos: a 61-bit number encoding the position of the center of this cell\n * along the Hilbert curve over this face (see the Wiki pages for details).\n *\n * Sequentially increasing cell ids follow a continuous space-filling curve over\n * the entire sphere. They have the following properties:\n *  - The id of a cell at level k consists of a 3-bit face number followed by k\n * bit pairs that recursively select one of the four children of each cell. The\n * next bit is always 1, and all other bits are 0. Therefore, the level of a\n * cell is determined by the position of its lowest-numbered bit that is turned\n * on (for a cell at level k, this position is 2 * (MAX_LEVEL - k).)\n *  - The id of a parent cell is at the midpoint of the range of ids spanned by\n * its children (or by its descendants at any level).\n *\n * Leaf cells are often used to represent points on the unit sphere, and this\n * class provides methods for converting directly between these two\n * representations. For cells that represent 2D regions rather than discrete\n * point, it is better to use the S2Cell class.\n *\n *\n */\nexport class S2CellId {\n\n  // Although only 60 bits are needed to represent the index of a leaf\n  // cell, we need an extra bit in order to represent the position of\n  // the center of the leaf cell along the Hilbert curve.\n  public static FACE_BITS = 3;\n  public static NUM_FACES = 6;\n  public static MAX_LEVEL = 30; // Valid levels: 0..MAX_LEVEL\n  public static POS_BITS = 2 * S2CellId.MAX_LEVEL + 1;\n  public static MAX_SIZE = 1 << S2CellId.MAX_LEVEL;\n\n\n//\n// calculated as 0xffffffffffffffff / radix\n\n  private static maxValueDivs = [new Long(0), new Long(0), // 0 and 1 are invalid\n    parseHex('9223372036854775807'), parseHex('6148914691236517205'), parseHex('4611686018427387903'), // 2-4\n    parseHex('3689348814741910323'), parseHex('3074457345618258602'), parseHex('2635249153387078802'), // 5-7\n    parseHex('2305843009213693951'), parseHex('2049638230412172401'), parseHex('1844674407370955161'), // 8-10\n    parseHex('1676976733973595601'), parseHex('1537228672809129301'), parseHex('1418980313362273201'), // 11-13\n    parseHex('1317624576693539401'), parseHex('1229782938247303441'), parseHex('1152921504606846975'), // 14-16\n    parseHex('1085102592571150095'), parseHex('1024819115206086200'), parseHex('970881267037344821'), // 17-19\n    parseHex('922337203685477580'), parseHex('878416384462359600'), parseHex('838488366986797800'), // 20-22\n    parseHex('802032351030850070'), parseHex('768614336404564650'), parseHex('737869762948382064'), // 23-25\n    parseHex('709490156681136600'), parseHex('683212743470724133'), parseHex('658812288346769700'), // 26-28\n    parseHex('636094623231363848'), parseHex('614891469123651720'), parseHex('595056260442243600'), // 29-31\n    parseHex('576460752303423487'), parseHex('558992244657865200'), parseHex('542551296285575047'), // 32-34\n    parseHex('527049830677415760'), parseHex('512409557603043100')] as Long[]; // 35-36\n\n\n// calculated as 0xffffffffffffffff % radix\n  private static maxValueMods = [0, 0, // 0 and 1 are invalid\n    1, 0, 3, 0, 3, 1, 7, 6, 5, 4, 3, 2, 1, 0, 15, 0, 15, 16, 15, 15, // 2-21\n    15, 5, 15, 15, 15, 24, 15, 23, 15, 15, 31, 15, 17, 15, 15]; // 22-36\n\n  // Constant related to unsigned long's\n  // '18446744073709551615'\n  // Long.fromString('0xffffffffffffffff', true, 16).toString()\n  // new Decimal(2).pow(64).sub(1);\n  public static MAX_UNSIGNED = Long.fromString('0xffffffffffffffff', true, 16);\n\n\n  // The following lookup tables are used to convert efficiently between an\n  // (i,j) cell index and the corresponding position along the Hilbert curve.\n  // \"lookup_pos\" maps 4 bits of \"i\", 4 bits of \"j\", and 2 bits representing the\n  // orientation of the current cell into 8 bits representing the order in which\n  // that subcell is visited by the Hilbert curve, plus 2 bits indicating the\n  // new orientation of the Hilbert curve within that subcell. (Cell\n  // orientations are represented as combination of kSwapMask and kInvertMask.)\n  //\n  // \"lookup_ij\" is an inverted table used for mapping in the opposite\n  // direction.\n  //\n  // We also experimented with looking up 16 bits at a time (14 bits of position\n  // plus 2 of orientation) but found that smaller lookup tables gave better\n  // performance. (2KB fits easily in the primary cache.)\n\n\n  // Values for these constants are *declared* in the *.h file. Even though\n  // the declaration specifies a value for the constant, that declaration\n  // is not a *definition* of storage for the value. Because the values are\n  // supplied in the declaration, we don't need the values here. Failing to\n  // define storage causes link errors for any code that tries to take the\n  // address of one of these values.\n  public static LOOKUP_BITS = 4;\n  private static SWAP_MASK = 0x01;\n  private static INVERT_MASK = 0x02;\n\n  public static LOOKUP_POS = [] as Long[];\n  public static LOOKUP_IJ = [] as number[];\n\n  /**\n   * This is the offset required to wrap around from the beginning of the\n   * Hilbert curve to the end or vice versa; see next_wrap() and prev_wrap().\n   */\n  private static WRAP_OFFSET = new Long(S2CellId.NUM_FACES).shiftLeft(S2CellId.POS_BITS);\n  //new Decimal(S2CellId.NUM_FACES).times(new Decimal(2).pow(S2CellId.POS_BITS));\n\n  public id: Long;\n  constructor(id:Long|string) {\n    if (typeof(id) === 'string') {\n      this.id = Long.fromString(id as string);\n    } else {\n      this.id = id as Long;\n    }\n\n  }\n\n  /** Which cube face this cell belongs to, in the range 0..5. */\n  get face() {\n    return this.id.shiftRightUnsigned(S2CellId.POS_BITS).toInt();\n  }\n\n  /** Return the lowest-numbered bit that is on for cells at the given level. */\n  public lowestOnBit():Long {\n    return this.id.and(this.id.negate());\n  }\n\n  /** The default constructor returns an invalid cell id. */\n  public static none():S2CellId {\n    return new S2CellId(new Long(0));\n  }\n\n  /**\n   * Returns an invalid cell id guaranteed to be larger than any valid cell id.\n   * Useful for creating indexes.\n   */\n  public static sentinel():S2CellId {\n    return new S2CellId(S2CellId.MAX_UNSIGNED); // -1\n  }\n\n\n  private  getBits1(i:MutableInteger, j:MutableInteger, k:number, bits:number):number {\n    let nbits = (k == 7) ? (S2CellId.MAX_LEVEL - 7 * S2CellId.LOOKUP_BITS) : S2CellId.LOOKUP_BITS;\n\n    bits += (this.id\n            .shiftRightUnsigned((k * 2 * S2CellId.LOOKUP_BITS + 1))\n            .getLowBitsUnsigned()\n            & ((1 << (2 * nbits)) - 1)) << 2;\n\n    /*\n     * System.out.println(\"id is: \" + id_); System.out.println(\"bits is \" +\n     * bits); System.out.println(\"lookup_ij[bits] is \" + lookup_ij[bits]);\n     */\n    bits = S2CellId.LOOKUP_IJ[bits];\n    i.val = i.val + ((bits >> (S2CellId.LOOKUP_BITS + 2)) << (k * S2CellId.LOOKUP_BITS));\n    // i.setValue(i.intValue() + ((bits >> (LOOKUP_BITS + 2)) << (k * LOOKUP_BITS)));\n    /*\n     * System.out.println(\"left is \" + ((bits >> 2) & ((1 << kLookupBits) -\n     * 1))); System.out.println(\"right is \" + (k * kLookupBits));\n     * System.out.println(\"j is: \" + j.intValue()); System.out.println(\"addition\n     * is: \" + ((((bits >> 2) & ((1 << kLookupBits) - 1))) << (k *\n     * kLookupBits)));\n     */\n    j.val = j.val + ((((bits >> 2) & ((1 << S2CellId.LOOKUP_BITS) - 1))) << (k * S2CellId.LOOKUP_BITS));\n\n    bits &= (S2.SWAP_MASK | S2.INVERT_MASK);\n    return bits;\n  }\n\n  /**\n   * Convert (face, si, ti) coordinates (see s2.h) to a direction vector (not\n   * necessarily unit length).\n   */\n  private faceSiTiToXYZ(face:number, si:number, ti:number):S2Point {\n    // console.log('faceSiTiToXYZ', si, ti);\n    let kScale = S2.toDecimal(1).dividedBy(S2CellId.MAX_SIZE);\n    let uvVector = R2Vector.fromSTVector(new R2Vector(kScale.times(si), kScale.times(ti)));\n    // console.log(uvVector.toString(), uvVector.x.toString());\n    return uvVector.toPoint(face);\n  }\n\n  public static lowestOnBitForLevel(level:number):Long {\n    return new Long(1).shiftLeft(2 * (S2CellId.MAX_LEVEL - level));\n  }\n\n  /**\n   * Return the (face, i, j) coordinates for the leaf cell corresponding to this\n   * cell id. Since cells are represented by the Hilbert curve position at the\n   * center of the cell, the returned (i,j) for non-leaf cells will be a leaf\n   * cell adjacent to the cell center. If \"orientation\" is non-NULL, also return\n   * the Hilbert curve orientation for the current cell.\n   */\n  public toFaceIJOrientation(pi:MutableInteger, pj:MutableInteger, orientation:MutableInteger) {\n    // System.out.println(\"Entering toFaceIjorientation\");\n    const face = this.face;\n    let bits = (face & S2.SWAP_MASK);\n\n    // System.out.println(\"face = \" + face + \" bits = \" + bits);\n\n    // Each iteration maps 8 bits of the Hilbert curve position into\n    // 4 bits of \"i\" and \"j\". The lookup table transforms a key of the\n    // form \"ppppppppoo\" to a value of the form \"iiiijjjjoo\", where the\n    // letters [ijpo] represents bits of \"i\", \"j\", the Hilbert curve\n    // position, and the Hilbert curve orientation respectively.\n    //\n    // On the first iteration we need to be careful to clear out the bits\n    // representing the cube face.\n    for (let k = 7; k >= 0; --k) {\n      bits = this.getBits1(pi, pj, k, bits);\n      // System.out.println(\"pi = \" + pi + \" pj= \" + pj + \" bits = \" + bits);\n    }\n\n    if (orientation != null) {\n      // The position of a non-leaf cell at level \"n\" consists of a prefix of\n      // 2*n bits that identifies the cell, followed by a suffix of\n      // 2*(MAX_LEVEL-n)+1 bits of the form 10*. If n==MAX_LEVEL, the suffix is\n      // just \"1\" and has no effect. Otherwise, it consists of \"10\", followed\n      // by (MAX_LEVEL-n-1) repetitions of \"00\", followed by \"0\". The \"10\" has\n      // no effect, while each occurrence of \"00\" has the effect of reversing\n      // the kSwapMask bit.\n      // assert (S2.POS_TO_ORIENTATION[2] == 0);\n      // assert (S2.POS_TO_ORIENTATION[0] == S2.SWAP_MASK);\n      if ((Long.fromString('0x1111111111111110', true, 16).and(this.lowestOnBit()).notEquals(0))) {\n        bits ^= S2.SWAP_MASK;\n      }\n      orientation.val = bits;\n    }\n    return face;\n  }\n\n\n  /**\n   * Return true if this is a leaf cell (more efficient than checking whether\n   * level() == MAX_LEVEL).\n   */\n  public  isLeaf():boolean {\n    return this.id.and(1).getLowBits() != 0;\n  }\n\n\n  /**\n   * Return the cell at the previous level or at the given level (which must be\n   * less than or equal to the current level).\n   */\n  public parentL(level:number):S2CellId {\n    // assert (isValid() && level >= 0 && level <= this.level());\n    let newLsb = S2CellId.lowestOnBitForLevel(level);\n    return new S2CellId(this.id.and(newLsb.negate()).or(newLsb))\n    // return new S2CellId((id & -newLsb) | newLsb);\n  }\n\n  public parent():S2CellId {\n    // assert (isValid() && level() > 0);\n    let newLsb = this.lowestOnBit().shiftLeft(2);\n    // return new S2CellId((id & -newLsb) | newLsb);\n    return new S2CellId(this.id.and(newLsb.negate()).or(newLsb))\n  }\n\n  /**\n   * Return a cell given its face (range 0..5), 61-bit Hilbert curve position\n   * within that face, and level (range 0..MAX_LEVEL). The given position will\n   * be modified to correspond to the Hilbert curve position at the center of\n   * the returned cell. This is a static function rather than a constructor in\n   * order to give names to the arguments.\n   */\n  public static fromFacePosLevel(face:number, pos:Long, level:number):S2CellId {\n    // equivalent to pos | 1\n\n    return new S2CellId(\n        new Long(face)\n            .shiftLeft(S2CellId.POS_BITS)\n            .add(pos.or(1))\n    ).parentL(level);\n    // return new S2CellId((((long) face) << POS_BITS) + (pos | 1)).parent(level);\n  }\n\n// /**\n//  * Return the leaf cell containing the given point (a direction vector, not\n//  * necessarily unit length).\n//  */\n  public static fromPoint(p:S2Point):S2CellId {\n    const face = p.toFace();\n    const uv = p.toR2Vector(face);\n    const i = S2CellId.stToIJ(uv.toSt(0));\n    const j = S2CellId.stToIJ(uv.toSt(1));\n    return S2CellId.fromFaceIJ(face, i, j);\n  }\n\n//\n//\n// /** Return the leaf cell containing the given S2LatLng. */\n// public static S2CellId fromLatLng(S2LatLng ll) {\n//   return fromPoint(ll.toPoint());\n// }\n\n  public toPoint():S2Point {\n    return S2Point.normalize(this.toPointRaw());\n  }\n\n  /**\n   * Return the direction vector corresponding to the center of the given cell.\n   * The vector returned by ToPointRaw is not necessarily unit length.\n   */\n  public toPointRaw():S2Point {\n    // First we compute the discrete (i,j) coordinates of a leaf cell contained\n    // within the given cell. Given that cells are represented by the Hilbert\n    // curve position corresponding at their center, it turns out that the cell\n    // returned by ToFaceIJOrientation is always one of two leaf cells closest\n    // to the center of the cell (unless the given cell is a leaf cell itself,\n    // in which case there is only one possibility).\n    //\n    // Given a cell of size s >= 2 (i.e. not a leaf cell), and letting (imin,\n    // jmin) be the coordinates of its lower left-hand corner, the leaf cell\n    // returned by ToFaceIJOrientation() is either (imin + s/2, jmin + s/2)\n    // (imin + s/2 - 1, jmin + s/2 - 1). We can distinguish these two cases by\n    // looking at the low bit of \"i\" or \"j\". In the first case the low bit is\n    // zero, unless s == 2 (i.e. the level just above leaf cells) in which case\n    // the low bit is one.\n    //\n    // The following calculation converts (i,j) to the (si,ti) coordinates of\n    // the cell center. (We need to multiply the coordinates by a factor of 2\n    // so that the center of leaf cells can be represented exactly.)\n    let i = new MutableInteger(0);\n    let j = new MutableInteger(0);\n    let face = this.toFaceIJOrientation(i, j, null);\n    // System.out.println(\"i= \" + i.intValue() + \" j = \" + j.intValue());\n    // let delta = isLeaf() ? 1 : (((i.intValue() ^ (((int) id) >>> 2)) & 1) != 0) ? 2 : 0;\n    let delta = this.isLeaf()\n        ? 1 :\n        ((((new Long(i.val).getLowBits() ^ (( this.id.getLowBits()) >>> 2)) & 1) != 0)\n            ? 2 : 0);\n\n\n    // let delta = this.isLeaf() ? 1 : new Long(i.val).and(this.id.getLowBits() >>> 2).and(1).notEquals(1) ? 2 : 0\n    // ((i.val ? (((int)id) >>> 2))  & 1  ))\n    let si = new Long((i.val << 1) + delta - S2CellId.MAX_SIZE).getLowBits();\n    let ti = new Long((j.val << 1) + delta - S2CellId.MAX_SIZE).getLowBits();\n\n    return this.faceSiTiToXYZ(face, si, ti);\n  }\n\n\n  /** Return the S2LatLng corresponding to the center of the given cell. */\n  public toLatLng():S2LatLng {\n    return S2LatLng.fromPoint(this.toPointRaw());\n  }\n\n\n  /** Return true if id() represents a valid cell. */\n  public isValid():boolean {\n    return this.face < S2CellId.NUM_FACES && ((this.lowestOnBit().and(Long.fromString('0x1555555555555555', false, 16)).notEquals(0)));\n    // return this.face() < NUM_FACES && ((lowestOnBit() & (0x1555555555555555L)) != 0);\n  }\n\n\n  /**\n   * The position of the cell center along the Hilbert curve over this face, in\n   * the range 0..(2**kPosBits-1).\n   */\n  public pos():Long {\n    return this.id.and(S2CellId.MAX_UNSIGNED.shiftRightUnsigned(S2CellId.FACE_BITS));\n    // return (id & (-1L >>> FACE_BITS));\n  }\n\n  /** Return the subdivision level of the cell (range 0..MAX_LEVEL). */\n  public level():number {\n    // Fast path for leaf cells.\n    if (this.isLeaf()) {\n      return S2CellId.MAX_LEVEL;\n    }\n    let x = this.id.getLowBits();\n    let level = -1;\n    if (x != 0) {\n      level += 16;\n    } else {\n      x = this.id.shiftRightUnsigned(32).getLowBits();\n      // (int) (id >>> 32);\n    }\n    // We only need to look at even-numbered bits to determine the\n    // level of a valid cell id.\n    x &= -x; // Get lowest bit.\n    if ((x & 0x00005555) != 0) {\n      level += 8;\n    }\n    if ((x & 0x00550055) != 0) {\n      level += 4;\n    }\n    if ((x & 0x05050505) != 0) {\n      level += 2;\n    }\n    if ((x & 0x11111111) != 0) {\n      level += 1;\n    }\n    // assert (level >= 0 && level <= MAX_LEVEL);\n    return level;\n  }\n\n  /**\n   * Return true if this is a top-level face cell (more efficient than checking\n   * whether level() == 0).\n   */\n  public isFace():boolean {\n    return this.level() === 0;\n    // return (id & (lowestOnBitForLevel(0) - 1)) == 0;\n  }\n\n  /**\n   * Return the child position (0..3) of this cell's ancestor at the given\n   * level, relative to its parent. The argument should be in the range\n   * 1..MAX_LEVEL. For example, child_position(1) returns the position of this\n   * cell's level-1 ancestor within its top-level face cell.\n   */\n  public childPosition(level:number):number {\n    return this.id.shiftRight((2 * (S2CellId.MAX_LEVEL - level) + 1)).and(3).getLowBits();\n    // return (int) (id >>> (2 * (MAX_LEVEL - level) + 1)) & 3;\n  }\n\n// Methods that return the range of cell ids that are contained\n// within this cell (including itself). The range is *inclusive*\n// (i.e. test using >= and <=) and the return values of both\n// methods are valid leaf cell ids.\n//\n// These methods should not be used for iteration. If you want to\n// iterate through all the leaf cells, call child_begin(MAX_LEVEL) and\n// child_end(MAX_LEVEL) instead.\n//\n// It would in fact be error-prone to define a range_end() method,\n// because (range_max().id() + 1) is not always a valid cell id, and the\n// iterator would need to be tested using \"<\" rather that the usual \"!=\".\n  public rangeMin():S2CellId {\n    return new S2CellId(this.id.sub(this.lowestOnBit().sub(1)));\n    // return new S2CellId(id - (lowestOnBit() - 1));\n  }\n\n  public rangeMax():S2CellId {\n    return new S2CellId(this.id.add(this.lowestOnBit().sub(1)));\n    // return new S2CellId(id + (lowestOnBit() - 1));\n  }\n\n//\n//\n  /** Return true if the given cell is contained within this one. */\n  public contains(other:S2CellId):boolean {\n    // assert (isValid() && other.isValid());\n    return other.greaterOrEquals(this.rangeMin()) && other.lessOrEquals(this.rangeMax());\n  }\n\n  /** Return true if the given cell intersects this one. */\n  public intersects(other:S2CellId):boolean {\n    // assert (isValid() && other.isValid());\n    return other.rangeMin().lessOrEquals(this.rangeMax())\n        && other.rangeMax().greaterOrEquals(this.rangeMin());\n  }\n\n\n  public childBegin():S2CellId {\n    // assert (isValid() && level() < MAX_LEVEL);\n    let oldLsb = this.lowestOnBit();\n    return new S2CellId(this.id.sub(oldLsb).add(oldLsb.shiftRight(2)));\n    // return new S2CellId(id - oldLsb + (oldLsb >>> 2));\n  }\n\n  public childBeginL(level:number):S2CellId {\n    // assert (isValid() && level >= this.level() && level <= MAX_LEVEL);\n    return new S2CellId(this.id.sub(this.lowestOnBit()).add(S2CellId.lowestOnBitForLevel(level)));\n    // return new S2CellId(id - lowestOnBit() + lowestOnBitForLevel(level));\n  }\n\n  public childEnd():S2CellId {\n    // assert (isValid() && level() < MAX_LEVEL);\n    let oldLsb = this.lowestOnBit();\n    return new S2CellId(this.id.add(oldLsb).add(oldLsb.shiftRightUnsigned(2)));\n    // return new S2CellId(id + oldLsb + (oldLsb >>> 2));\n  }\n\n  public childEndL(level:number):S2CellId {\n    // assert (isValid() && level >= this.level() && level <= MAX_LEVEL);\n    return new S2CellId(this.id.add(this.lowestOnBit()).add(S2CellId.lowestOnBitForLevel(level)));\n    // return new S2CellId(id + lowestOnBit() + lowestOnBitForLevel(level));\n  }\n\n//\n// Iterator-style methods for traversing the immediate children of a cell or\n// all of the children at a given level (greater than or equal to the current\n// level). Note that the end value is exclusive, just like standard STL\n// iterators, and may not even be a valid cell id. You should iterate using\n// code like this:\n//\n// for(S2CellId c = id.childBegin(); !c.equals(id.childEnd()); c = c.next())\n// ...\n//\n// The convention for advancing the iterator is \"c = c.next()\", so be sure\n// to use 'equals()' in the loop guard, or compare 64-bit cell id's,\n// rather than \"c != id.childEnd()\".\n\n  /**\n   * Return the next cell at the same level along the Hilbert curve. Works\n   * correctly when advancing from one face to the next, but does *not* wrap\n   * around from the last face to the first or vice versa.\n   */\n  public next():S2CellId {\n    return new S2CellId(this.id.add(this.lowestOnBit().shiftLeft(1)));\n    // return new S2CellId(id + (lowestOnBit() << 1));\n  }\n\n  /**\n   * Return the previous cell at the same level along the Hilbert curve. Works\n   * correctly when advancing from one face to the next, but does *not* wrap\n   * around from the last face to the first or vice versa.\n   */\n  public prev():S2CellId {\n    return new S2CellId(this.id.sub(this.lowestOnBit().shiftLeft(1)));\n    // return new S2CellId(id - (lowestOnBit() << 1));\n  }\n\n\n  /**\n   * Like next(), but wraps around from the last face to the first and vice\n   * versa. Should *not* be used for iteration in conjunction with\n   * child_begin(), child_end(), Begin(), or End().\n   */\n  public nextWrap():S2CellId {\n    let n = this.next();\n    if (S2CellId.unsignedLongLessThan(n.id, S2CellId.WRAP_OFFSET)) {\n      return n;\n    }\n    return new S2CellId(n.id.sub(S2CellId.WRAP_OFFSET));\n    // return new S2CellId(n.id - WRAP_OFFSET);\n  }\n\n  /**\n   * Like prev(), but wraps around from the last face to the first and vice\n   * versa. Should *not* be used for iteration in conjunction with\n   * child_begin(), child_end(), Begin(), or End().\n   */\n  public prevWrap():S2CellId {\n    let p = this.prev();\n    if (p.id.lessThan(S2CellId.WRAP_OFFSET)) {\n      return p;\n    }\n    return new S2CellId(p.id.add(S2CellId.WRAP_OFFSET));\n  }\n\n\n  static begin(level:number):S2CellId {\n    return S2CellId.fromFacePosLevel(0, new Long(0), 0).childBeginL(level);\n  }\n\n  static end(level:number):S2CellId {\n    return S2CellId.fromFacePosLevel(5, new Long(0), 0).childEndL(level);\n  }\n\n\n  /**\n   * Decodes the cell id from a compact text string suitable for display or\n   * indexing. Cells at lower levels (i.e. larger cells) are encoded into\n   * fewer characters. The maximum token length is 16.\n   *\n   * @param token the token to decode\n   * @return the S2CellId for that token\n   * @throws NumberFormatException if the token is not formatted correctly\n   */\n  public static fromToken(token:string):S2CellId {\n    if (token == null) {\n      throw new Error(\"Null string in S2CellId.fromToken\");\n    }\n    if (token.length == 0) {\n      throw new Error(\"Empty string in S2CellId.fromToken\");\n    }\n    if (token.length > 16 || \"X\" == token) {\n      return S2CellId.none();\n    }\n\n    let value = new Long(0);\n    for (let pos = 0; pos < 16; pos++) {\n      let digit = new Long(0);\n      if (pos < token.length) {\n        digit = Long.fromString(token[pos], true, 16);\n        if (digit.equals(-1)) {\n          throw new Error(token);\n        }\n        if (S2CellId.overflowInParse(value, digit.toNumber())) {\n          throw new Error(\"Too large for unsigned long: \" + token);\n        }\n      }\n      value = value.mul(16).add(digit);\n      // (value * 16) + digit;\n    }\n\n    return new S2CellId(value);\n  }\n\n  /**\n   * Encodes the cell id to compact text strings suitable for display or indexing.\n   * Cells at lower levels (i.e. larger cells) are encoded into fewer characters.\n   * The maximum token length is 16.\n   *\n   * Simple implementation: convert the id to hex and strip trailing zeros. We\n   * could use base-32 or base-64, but assuming the cells used for indexing\n   * regions are at least 100 meters across (level 16 or less), the savings\n   * would be at most 3 bytes (9 bytes hex vs. 6 bytes base-64).\n   *\n   * @return the encoded cell id\n   */\n  public toToken():string {\n    if (this.id.equals(0)) {\n      return \"X\";\n    }\n\n    let hex = this.id.toUnsigned().toString(16);\n\n    // Long.toHexString(id).toLowerCase(Locale.ENGLISH);\n    let sb = '';\n    for (let i = hex.length; i < 16; i++) {\n      sb += '0';\n      // sb.append('0');\n    }\n    sb += hex;\n    // sb.append(hex);\n    for (let len = 16; len > 0; len--) {\n      if (sb[len - 1] != '0') {\n        return sb.substring(0, len);\n      }\n    }\n\n    throw new Error(\"Shouldn't make it here\");\n  }\n\n\n  /**\n   * Returns true if (current * radix) + digit is a number too large to be\n   * represented by an unsigned long.  This is useful for detecting overflow\n   * while parsing a string representation of a number.\n   * Does not verify whether supplied radix is valid, passing an invalid radix\n   * will give undefined results or an ArrayIndexOutOfBoundsException.\n   */\n  private static overflowInParse(current:Long, digit:number, radix:number = 10):boolean {\n    if (current.greaterThanOrEqual(0)) {\n      if (current.lessThan(S2CellId.maxValueDivs[radix])) {\n        return false;\n      }\n      if (current.greaterThan(S2CellId.maxValueDivs[radix])) {\n        return true;\n      }\n      // current == maxValueDivs[radix]\n      return (digit > S2CellId.maxValueMods[radix]);\n    }\n\n    // current < 0: high bit is set\n    return true;\n  }\n\n  /**\n   * Return the four cells that are adjacent across the cell's four edges.\n   * Neighbors are returned in the order defined by S2Cell::GetEdge. All\n   * neighbors are guaranteed to be distinct.\n   */\n  public getEdgeNeighbors():S2CellId[] {\n\n    const i = new MutableInteger(0);\n    const j = new MutableInteger(0);\n\n    let level = this.level();\n    let size = 1 << (S2CellId.MAX_LEVEL - level);\n    let face = this.toFaceIJOrientation(i, j, null);\n\n    let neighbors = [] as S2CellId[];\n    // Edges 0, 1, 2, 3 are in the S, E, N, W directions.\n    neighbors.push(\n        S2CellId.fromFaceIJSame(face, i.val, j.val - size, j.val - size >= 0).parentL(level)\n    );\n    neighbors.push(\n        S2CellId.fromFaceIJSame(face, i.val + size, j.val, i.val + size < S2CellId.MAX_SIZE).parentL(level)\n    );\n    neighbors.push(\n        S2CellId.fromFaceIJSame(face, i.val, j.val + size, j.val + size < S2CellId.MAX_SIZE).parentL(level)\n    );\n    neighbors.push(\n        S2CellId.fromFaceIJSame(face, i.val - size, j.val, i.val - size >= 0).parentL(level)\n    );\n    // neighbors[0] = fromFaceIJSame(face, i.intValue(), j.intValue() - size,\n    //     j.intValue() - size >= 0).parent(level);\n    // neighbors[1] = fromFaceIJSame(face, i.intValue() + size, j.intValue(),\n    //     i.intValue() + size < MAX_SIZE).parent(level);\n    // neighbors[2] = fromFaceIJSame(face, i.intValue(), j.intValue() + size,\n    //     j.intValue() + size < MAX_SIZE).parent(level);\n    // neighbors[3] = fromFaceIJSame(face, i.intValue() - size, j.intValue(),\n    //     i.intValue() - size >= 0).parent(level);\n    return neighbors;\n  }\n\n\n/**\n * Return the neighbors of closest vertex to this cell at the given level, by\n * appending them to \"output\". Normally there are four neighbors, but the\n * closest vertex may only have three neighbors if it is one of the 8 cube\n * vertices.\n *\n * Requires: level < this.evel(), so that we can determine which vertex is\n * closest (in particular, level == MAX_LEVEL is not allowed).\n */\npublic  getVertexNeighbors(level:number):S2CellId[] {\n  // \"level\" must be strictly less than this cell's level so that we can\n  // determine which vertex this cell is closest to.\n  // assert (level < this.level());\n  const i = new MutableInteger(0);\n  const j = new MutableInteger(0);\n  const face = this.toFaceIJOrientation(i, j, null);\n\n  // Determine the i- and j-offsets to the closest neighboring cell in each\n  // direction. This involves looking at the next bit of \"i\" and \"j\" to\n  // determine which quadrant of this->parent(level) this cell lies in.\n  const halfsize = 1 << (S2CellId.MAX_LEVEL - (level + 1));\n  const size = halfsize << 1;\n  let isame:boolean, jsame:boolean;\n  let ioffset, joffset;\n  if ((i.val & halfsize) != 0) {\n    ioffset = size;\n    isame = (i.val + size) < S2CellId.MAX_SIZE;\n  } else {\n    ioffset = -size;\n    isame = (i.val - size) >= 0;\n  }\n  if ((j.val & halfsize) != 0) {\n    joffset = size;\n    jsame = (j.val + size) < S2CellId.MAX_SIZE;\n  } else {\n    joffset = -size;\n    jsame = (j.val - size) >= 0;\n  }\n  const toRet = [];\n  toRet.push(this.parentL(level));\n\n  toRet.push(\n      S2CellId\n          .fromFaceIJSame(face, i.val+ ioffset, j.val, isame)\n          .parentL(level)\n  );\n  // output\n  //     .add(fromFaceIJSame(face, i.intValue() + ioffset, j.intValue(), isame)\n  //         .parent(level));\n  toRet.push(\n      S2CellId\n          .fromFaceIJSame(face, i.val, j.val+joffset, jsame)\n          .parentL(level)\n  );\n  // output\n  //     .add(fromFaceIJSame(face, i.intValue(), j.intValue() + joffset, jsame)\n  //         .parent(level));\n  // If i- and j- edge neighbors are *both* on a different face, then this\n  // vertex only has three neighbors (it is one of the 8 cube vertices).\n  if (isame || jsame) {\n    toRet.push(\n        S2CellId.fromFaceIJSame(\n            face,\n            i.val+ioffset,\n            j.val+joffset,\n            isame && jsame\n        ).parentL(level)\n    );\n    // output.add(fromFaceIJSame(face, i.intValue() + ioffset,\n    //     j.intValue() + joffset, isame && jsame).parent(level));\n  }\n  return toRet;\n}\n\n  /**\n   * Append all neighbors of this cell at the given level to \"output\". Two cells\n   * X and Y are neighbors if their boundaries intersect but their interiors do\n   * not. In particular, two cells that intersect at a single point are\n   * neighbors.\n   *\n   * Requires: nbr_level >= this->level(). Note that for cells adjacent to a\n   * face vertex, the same neighbor may be appended more than once.\n   */\n  public getAllNeighbors(nbrLevel:number):S2CellId[] {\n    const i = new MutableInteger(0);\n    const j = new MutableInteger(0);\n\n    let face = this.toFaceIJOrientation(i, j, null);\n\n    // Find the coordinates of the lower left-hand leaf cell. We need to\n    // normalize (i,j) to a known position within the cell because nbr_level\n    // may be larger than this cell's level.\n    let size = 1 << (S2CellId.MAX_LEVEL - this.level());\n    i.val = i.val & -size;\n    j.val = j.val & -size;\n\n    let nbrSize = 1 << (S2CellId.MAX_LEVEL - nbrLevel);\n    // assert (nbrSize <= size);\n\n    let output = [];\n    // We compute the N-S, E-W, and diagonal neighbors in one pass.\n    // The loop test is at the end of the loop to avoid 32-bit overflow.\n    for (let k = -nbrSize; ; k += nbrSize) {\n      let sameFace;\n      if (k < 0) {\n        sameFace = (j.val + k >= 0);\n      } else if (k >= size) {\n        sameFace = (j.val + k < S2CellId.MAX_SIZE);\n      } else {\n        sameFace = true;\n        // North and South neighbors.\n        output.push(S2CellId.fromFaceIJSame(face, i.val + k,\n            j.val - nbrSize, j.val - size >= 0).parentL(nbrLevel));\n        output.push(S2CellId.fromFaceIJSame(face, i.val + k, j.val + size,\n            j.val + size < S2CellId.MAX_SIZE).parentL(nbrLevel));\n      }\n      // East, West, and Diagonal neighbors.\n      output.push(S2CellId.fromFaceIJSame(face, i.val - nbrSize,\n          j.val + k, sameFace && i.val - size >= 0).parentL(\n          nbrLevel));\n      output.push(S2CellId.fromFaceIJSame(face, i.val + size, j.val + k,\n          sameFace && i.val + size < S2CellId.MAX_SIZE).parentL(nbrLevel));\n      if (k >= size) {\n        break;\n      }\n    }\n    return output;\n  }\n\n// ///////////////////////////////////////////////////////////////////\n// Low-level methods.\n\n  /**\n   * Return a leaf cell given its cube face (range 0..5) and i- and\n   * j-coordinates (see s2.h).\n   */\n  public static fromFaceIJ(face:number, i:number, j:number):S2CellId {\n    // Optimization notes:\n    // - Non-overlapping bit fields can be combined with either \"+\" or \"|\".\n    // Generally \"+\" seems to produce better code, but not always.\n\n    // gcc doesn't have very good code generation for 64-bit operations.\n    // We optimize this by computing the result as two 32-bit integers\n    // and combining them at the end. Declaring the result as an array\n    // rather than local variables helps the compiler to do a better job\n    // of register allocation as well. Note that the two 32-bits halves\n    // get shifted one bit to the left when they are combined.\n    const faceL = new Long(face);\n    const n = [new Long(0), faceL.shiftLeft(S2CellId.POS_BITS - 33)];\n\n    // Alternating faces have opposite Hilbert curve orientations; this\n    // is necessary in order for all faces to have a right-handed\n    // coordinate system.\n    let bits = faceL.and(S2CellId.SWAP_MASK);\n\n    // Each iteration maps 4 bits of \"i\" and \"j\" into 8 bits of the Hilbert\n    // curve position. The lookup table transforms a 10-bit key of the form\n    // \"iiiijjjjoo\" to a 10-bit value of the form \"ppppppppoo\", where the\n    // letters [ijpo] denote bits of \"i\", \"j\", Hilbert curve position, and\n    // Hilbert curve orientation respectively.\n\n    for (let k = 7; k >= 0; --k) {\n      bits = S2CellId.getBits(n, i, j, k, bits);\n    }\n\n    // S2CellId s = new S2CellId((((n[1] << 32) + n[0]) << 1) + 1);\n    return new S2CellId(\n        n[1].shiftLeft(32)\n            .add(n[0])\n            .shiftLeft(1)\n            .add(1)\n    );\n  }\n\n  private static getBits(n:Long[], i:number, j:number, k:number, bits:Long):Long {\n\n    const mask = new Long(1).shiftLeft(S2CellId.LOOKUP_BITS).sub(1);\n    bits = bits.add(\n        new Long(i)\n            .shiftRight(k * S2CellId.LOOKUP_BITS)\n            .and(mask)\n            .shiftLeft(S2CellId.LOOKUP_BITS + 2)\n    );\n    // bits += (((i >> (k * LOOKUP_BITS)) & mask) << (LOOKUP_BITS + 2));\n    bits = bits.add(\n        new Long(j)\n            .shiftRight(k * S2CellId.LOOKUP_BITS)\n            .and(mask)\n            .shiftLeft(2)\n    );\n    // bits += (((j >> (k * LOOKUP_BITS)) & mask) << 2);\n\n    bits = S2CellId.LOOKUP_POS[bits.toNumber()];\n    n[k >> 2] = n[k >> 2].or(\n        bits.shiftRight(2).shiftLeft((k & 3) * 2 * S2CellId.LOOKUP_BITS)\n    );\n    // n[k >> 2] |= ((((long) bits) >> 2) << ((k & 3) * 2 * LOOKUP_BITS));\n\n    return bits.and(S2CellId.SWAP_MASK | S2CellId.INVERT_MASK);\n  }\n\n  /**\n   * Return the i- or j-index of the leaf cell containing the given s- or\n   * t-value.\n   */\n  private static stToIJ(_s:number|decimal.Decimal):number {\n    // Converting from floating-point to integers via static_cast is very slow\n    // on Intel processors because it requires changing the rounding mode.\n    // Rounding to the nearest integer using FastIntRound() is much faster.\n    let s = S2.toDecimal(_s);\n    let m = S2.toDecimal(S2CellId.MAX_SIZE).dividedBy(2); // scaling multiplier\n    return decimal.Decimal.max(\n        0,\n        decimal.Decimal.min(\n            m.times(2).minus(1),\n            decimal.Decimal.round(\n                m.times(s).plus(\n                    m.minus(0.5)\n                )\n            )\n        )\n    ).toNumber();\n    // return Math.max(0,  Math.min(2 * m - 1, Math.round(m * s + (m - 0.5))));\n    // return (int) Math.max(0, Math.min(2 * m - 1, Math.round(m * s + (m - 0.5))));\n  }\n\n\n  /**\n   * Given (i, j) coordinates that may be out of bounds, normalize them by\n   * returning the corresponding neighbor cell on an adjacent face.\n   */\n  private static  fromFaceIJWrap(face:number, i:number, j:number):S2CellId {\n    // Convert i and j to the coordinates of a leaf cell just beyond the\n    // boundary of this face. This prevents 32-bit overflow in the case\n    // of finding the neighbors of a face cell, and also means that we\n    // don't need to worry about the distinction between (s,t) and (u,v).\n    i = Math.max(-1, Math.min(S2CellId.MAX_SIZE, i));\n    j = Math.max(-1, Math.min(S2CellId.MAX_SIZE, j));\n\n    // Find the (s,t) coordinates corresponding to (i,j). At least one\n    // of these coordinates will be just outside the range [0, 1].\n    const kScale = S2.toDecimal(1.0).dividedBy(S2CellId.MAX_SIZE) ;\n    let s = kScale.times(new Long(i).shiftLeft(1).add(1).sub(S2CellId.MAX_SIZE).toInt());\n    let t = kScale.times(new Long(j).shiftLeft(1).add(1).sub(S2CellId.MAX_SIZE).toInt());\n    // Find the leaf cell coordinates on the adjacent face, and convert\n    // them to a cell id at the appropriate level.\n    let p = new R2Vector(s, t).toPoint(face);\n    face = p.toFace();\n    // face = S2Projections.xyzToFace(p);\n    let st = p.toR2Vector(face)\n    // R2Vector st = S2Projections.validFaceXyzToUv(face, p);\n\n    return S2CellId.fromFaceIJ(face, S2CellId.stToIJ(st.x), S2CellId.stToIJ(st.y));\n  }\n\n  /**\n   * Public helper function that calls FromFaceIJ if sameFace is true, or\n   * FromFaceIJWrap if sameFace is false.\n   */\n  public static fromFaceIJSame(face:number, i:number, j:number, sameFace:boolean):S2CellId {\n    if (sameFace) {\n      return S2CellId.fromFaceIJ(face, i, j);\n    } else {\n      return S2CellId.fromFaceIJWrap(face, i, j);\n    }\n  }\n\n\n  /**\n   * Returns true if x1 < x2, when both values are treated as unsigned.\n   */\n  public static unsignedLongLessThan(x1:Long, x2:Long):boolean {\n    return x1.toUnsigned().lessThan(x2.toUnsigned());\n\n    // return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);\n  }\n\n  /**\n   * Returns true if x1 > x2, when both values are treated as unsigned.\n   */\n  public static unsignedLongGreaterThan(x1:Long, x2:Long):boolean {\n    return x1.toUnsigned().greaterThan(x2.toUnsigned());\n    // return (x1 + Long.MIN_VALUE) > (x2 + Long.MIN_VALUE);\n  }\n\n  public lessThan(x:S2CellId):boolean {\n    return S2CellId.unsignedLongLessThan(this.id, x.id);\n  }\n\n  public greaterThan(x:S2CellId):boolean {\n    return S2CellId.unsignedLongGreaterThan(this.id, x.id);\n  }\n\n  public lessOrEquals(x:S2CellId):boolean {\n    return S2CellId.unsignedLongLessThan(this.id, x.id) || this.id.equals(x.id);\n  }\n\n  public greaterOrEquals(x:S2CellId):boolean {\n    return S2CellId.unsignedLongGreaterThan(this.id, x.id) || this.id.equals(x.id);\n  }\n\n  public  toString():string {\n    return \"(face=\" + this.face + \", pos=\" + this.pos().toString(16) + \", level=\"\n        + this.level() + \")\";\n  }\n\n  public compareTo(that:S2CellId ):number {\n    return S2CellId.unsignedLongLessThan(this.id, that.id) ? -1 :\n        S2CellId.unsignedLongGreaterThan(this.id, that.id) ? 1 : 0;\n  }\n\n  public equals(that:S2CellId): boolean {\n    return this.compareTo(that) === 0;\n  }\n\n  /**\n   * Returns the position of the id within the given list or a negative value with\n   * the position of the index wher eit should be entered if the id was present\n   */\n  public static binarySearch(ids:S2CellId[], _id:Long|string|S2CellId, low:number=0 ):number {\n    let id:S2CellId;\n    if (_id instanceof S2CellId) {\n      id = _id;\n    } else if(_id instanceof Long) {\n      id = new S2CellId(_id);\n    }\n    let high = ids.length-1;\n\n    while (low <= high) {\n      const mid = (low + high) >>> 1;\n      const midVal = ids[mid];\n      let cmp = midVal.compareTo(id);\n\n      if (cmp < 0)\n        low = mid + 1;\n      else if (cmp > 0)\n        high = mid - 1;\n      else\n        return mid; // key found\n    }\n    return -(low + 1);  // key not found\n  }\n\n  public static indexedBinarySearch(ids:S2CellId[], id:Long|string|S2CellId, low:number=0 ):number {\n    const toRet = this.binarySearch(ids, id, low)\n    if (toRet >= 0) {\n      return toRet;\n    } else {\n      return -(toRet+1);\n    }\n\n  }\n\n}\n\n\nfunction initLookupCell(level:number, i:number, j:number,\n                        origOrientation:number, pos:Long, orientation:number) {\n  if (level == S2CellId.LOOKUP_BITS) {\n    let ij = (i << S2CellId.LOOKUP_BITS) + j;\n    S2CellId.LOOKUP_POS[(ij << 2) + origOrientation] = pos.shiftLeft(2).add(orientation);\n    S2CellId.LOOKUP_IJ[pos.shiftLeft(2).add(origOrientation).toNumber()] = (ij << 2) + orientation;\n    // new Long((ij << 2)).add(orientation);\n  } else {\n    level++;\n    i <<= 1;\n    j <<= 1;\n    pos = pos.shiftLeft(2);\n    // Initialize each sub-cell recursively.\n    for (let subPos = 0; subPos < 4; subPos++) {\n      let ij = S2.POS_TO_IJ[orientation][subPos];\n      let orientationMask = S2.POS_TO_ORIENTATION[subPos];\n      initLookupCell(level, i + (ij >>> 1), j + (ij & 1), origOrientation,\n          pos.add(subPos), orientation ^ orientationMask);\n    }\n  }\n}\n\ninitLookupCell(0, 0, 0, 0, new Long(0), 0);\ninitLookupCell(0, 0, 0, S2.SWAP_MASK, new Long(0), S2.SWAP_MASK);\ninitLookupCell(0, 0, 0, S2.INVERT_MASK, new Long(0), S2.INVERT_MASK);\ninitLookupCell(0, 0, 0, S2.SWAP_MASK | S2.INVERT_MASK, new Long(0), S2.SWAP_MASK | S2.INVERT_MASK);\n","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * This class specifies the details of how the cube faces are projected onto the\n * unit sphere. This includes getting the face ordering and orientation correct\n * so that sequentially increasing cell ids follow a continuous space-filling\n * curve over the entire sphere, and defining the transformation from cell-space\n * to cube-space (see s2.h) in order to make the cells more uniform in size.\n *\n *\n *  We have implemented three different projections from cell-space (s,t) to\n * cube-space (u,v): linear, quadratic, and tangent. They have the following\n * tradeoffs:\n *\n *  Linear - This is the fastest transformation, but also produces the least\n * uniform cell sizes. Cell areas vary by a factor of about 5.2, with the\n * largest cells at the center of each face and the smallest cells in the\n * corners.\n *\n *  Tangent - Transforming the coordinates via atan() makes the cell sizes more\n * uniform. The areas vary by a maximum ratio of 1.4 as opposed to a maximum\n * ratio of 5.2. However, each call to atan() is about as expensive as all of\n * the other calculations combined when converting from points to cell ids, i.e.\n * it reduces performance by a factor of 3.\n *\n *  Quadratic - This is an approximation of the tangent projection that is much\n * faster and produces cells that are almost as uniform in size. It is about 3\n * times faster than the tangent projection for converting cell ids to points,\n * and 2 times faster for converting points to cell ids. Cell areas vary by a\n * maximum ratio of about 2.1.\n *\n *  Here is a table comparing the cell uniformity using each projection. \"Area\n * ratio\" is the maximum ratio over all subdivision levels of the largest cell\n * area to the smallest cell area at that level, \"edge ratio\" is the maximum\n * ratio of the longest edge of any cell to the shortest edge of any cell at the\n * same level, and \"diag ratio\" is the ratio of the longest diagonal of any cell\n * to the shortest diagonal of any cell at the same level. \"ToPoint\" and\n * \"FromPoint\" are the times in microseconds required to convert cell ids to and\n * from points (unit vectors) respectively.\n *\n *  Area Edge Diag ToPoint FromPoint Ratio Ratio Ratio (microseconds)\n * ------------------------------------------------------- Linear: 5.200 2.117\n * 2.959 0.103 0.123 Tangent: 1.414 1.414 1.704 0.290 0.306 Quadratic: 2.082\n * 1.802 1.932 0.116 0.161\n *\n *  The worst-case cell aspect ratios are about the same with all three\n * projections. The maximum ratio of the longest edge to the shortest edge\n * within the same cell is about 1.4 and the maximum ratio of the diagonals\n * within the same cell is about 1.7.\n *\n * This data was produced using s2cell_unittest and s2cellid_unittest.\n *\n */\nimport {S2, S2Metric} from \"./S2\";\nimport {S2Point} from \"./S2Point\";\nimport {R2Vector} from \"./R2Vector\";\nimport * as decimal from 'decimal.js';\nexport enum Projections { \n  S2_LINEAR_PROJECTION, S2_TAN_PROJECTION, S2_QUADRATIC_PROJECTION\n}\nexport class S2Projections {\n\n  public static MIN_WIDTH= new S2Metric(1,S2.M_SQRT2 / 3);\n  public static AVG_AREA = new S2Metric(2, S2.M_PI / 6); // 0.524)\n\n  public static getUNorm(face:number, u:decimal.Decimal):S2Point {\n    switch (face) {\n      case 0:\n        return new S2Point(u, -1, 0);\n      case 1:\n        return new S2Point(1, u, 0);\n      case 2:\n        return new S2Point(1, 0, u);\n      case 3:\n        return new S2Point(-u, 0, 1);\n      case 4:\n        return new S2Point(0, -u, 1);\n      default:\n        return new S2Point(0, -1, -u);\n    }\n  }\n\n  public static getVNorm(face:number, v:decimal.Decimal):S2Point {\n    switch (face) {\n      case 0:\n        return new S2Point(-v, 0, 1);\n      case 1:\n        return new S2Point(0, -v, 1);\n      case 2:\n        return new S2Point(0, -1, -v);\n      case 3:\n        return new S2Point(v, -1, 0);\n      case 4:\n        return new S2Point(1, v, 0);\n      default:\n        return new S2Point(1, 0, v);\n    }\n  }\n\n\n  public static  getUAxis(face:number):S2Point {\n    switch (face) {\n      case 0:\n        return new S2Point(0, 1, 0);\n      case 1:\n        return new S2Point(-1, 0, 0);\n      case 2:\n        return new S2Point(-1, 0, 0);\n      case 3:\n        return new S2Point(0, 0, -1);\n      case 4:\n        return new S2Point(0, 0, -1);\n      default:\n        return new S2Point(0, 1, 0);\n    }\n  }\n\n  public static getVAxis(face:number):S2Point {\n    switch (face) {\n      case 0:\n        return new S2Point(0, 0, 1);\n      case 1:\n        return new S2Point(0, 0, 1);\n      case 2:\n        return new S2Point(0, -1, 0);\n      case 3:\n        return new S2Point(0, -1, 0);\n      case 4:\n        return new S2Point(1, 0, 0);\n      default:\n        return new S2Point(1, 0, 0);\n    }\n  }\n\n  public static faceUvToXyz(face: number, u:number|decimal.Decimal, v:number|decimal.Decimal):S2Point {\n    return new R2Vector(u,v).toPoint(face);\n  }\n}\n","import Long from 'long';\nimport * as decimal from 'decimal.js';\nimport {S2CellId} from \"./S2CellId\";\nimport {S2Point} from \"./S2Point\";\nimport {S2LatLng} from \"./S2LatLng\";\nimport {S2Projections} from \"./S2Projections\";\nimport {R2Vector} from \"./R2Vector\";\nimport {MutableInteger} from \"./MutableInteger\";\nimport {S2} from \"./S2\";\nimport {S2LatLngRect} from \"./S2LatLngRect\";\nimport {R1Interval} from \"./R1Interval\";\nimport {S1Interval} from \"./S1Interval\";\nimport {S2Cap} from \"./S2Cap\";\nexport class S2Cell {\n  private static MAX_CELL_SIZE = 1 << S2CellId.MAX_LEVEL;\n\n  private _face:number;\n  private _level:number;\n  private _orientation:number;\n  private _uv:decimal.Decimal[][];\n\n  constructor(private cellID:S2CellId) {\n    this._uv = [];\n    this._uv.push([]);\n    this._uv.push([]);\n    this.init(cellID)\n  }\n\n  get id():S2CellId {\n    return this.cellID;\n  }\n\n  get face():number {\n    return this._face;\n  }\n\n  get level():number {\n    return this._level;\n  }\n\n  get orientation():number {\n    return this._orientation;\n  }\n\n\n\n// This is a static method in order to provide named parameters.\n  public static fromFacePosLevel(face:number, pos:number, level:number):S2Cell {\n    return new S2Cell(S2CellId.fromFacePosLevel(face, new Long(pos), level));\n  }\n\n// Convenience methods.\n  public static fromPoint(p:S2Point):S2Cell {\n    return new S2Cell(S2CellId.fromPoint(p))\n  }\n\n  public static fromLatLng(ll:S2LatLng):S2Cell {\n    return new S2Cell(S2CellId.fromPoint(ll.toPoint()));\n  }\n\n\n  public isLeaf():boolean {\n    return this.level == S2CellId.MAX_LEVEL;\n  }\n\n  public getVertex(k:number):S2Point {\n    return S2Point.normalize(this.getVertexRaw(k));\n  }\n\n  /**\n   * Return the k-th vertex of the cell (k = 0,1,2,3). Vertices are returned in\n   * CCW order. The points returned by GetVertexRaw are not necessarily unit\n   * length.\n   */\n  public getVertexRaw(k:number):S2Point {\n    // Vertices are returned in the order SW, SE, NE, NW.\n\n    return new R2Vector(this._uv[0][(k >> 1) ^ (k & 1)], this._uv[1][k >> 1])\n        .toPoint(this.face);\n    // return S2Projections.faceUvToXyz(this.face, );\n  }\n\n  public getEdge(k:number):S2Point {\n    return S2Point.normalize(this.getEdgeRaw(k));\n  }\n\n  public getEdgeRaw(k:number):S2Point {\n    switch (k) {\n      case 0:\n        return S2Projections.getVNorm(this.face, this._uv[1][0]); // South\n      case 1:\n        return S2Projections.getUNorm(this.face, this._uv[0][1]); // East\n      case 2:\n        return S2Point.neg(S2Projections.getVNorm(this.face, this._uv[1][1])); // North\n      default:\n        return S2Point.neg(S2Projections.getUNorm(this.face, this._uv[0][0])); // West\n    }\n  }\n\n\n  /**\n   * Return the inward-facing normal of the great circle passing through the\n   * edge from vertex k to vertex k+1 (mod 4). The normals returned by\n   * GetEdgeRaw are not necessarily unit length.\n   *\n   *  If this is not a leaf cell, set children[0..3] to the four children of\n   * this cell (in traversal order) and return true. Otherwise returns false.\n   * This method is equivalent to the following:\n   *\n   *  for (pos=0, id=child_begin(); id != child_end(); id = id.next(), ++pos)\n   * children[i] = S2Cell(id);\n   *\n   * except that it is more than two times faster.\n   */\n  public subdivide():S2Cell[] {\n    // This function is equivalent to just iterating over the child cell ids\n    // and calling the S2Cell constructor, but it is about 2.5 times faster.\n\n    if (this.isLeaf()) {\n      return null;\n    }\n\n    // Compute the cell midpoint in uv-space.\n    // const uvMid = this.getCenterUV();\n    const children:S2Cell[] = new Array(4);\n    // Create four children with the appropriate bounds.\n    let id = this.cellID.childBegin();\n    for (let pos = 0; pos < 4; ++pos, id = id.next()) {\n      children[pos] = new S2Cell(id);\n      // S2Cell child = children[pos];\n      // child.face = this.face;\n      // child.level = (byte) (this.level + 1);\n      // child.orientation = (byte) (this.orientation ^ S2.posToOrientation(pos));\n      // child.cellId = id;\n      // int ij = S2.posToIJ(this.orientation, pos);\n      // for (let d = 0; d < 2; ++d) {\n      //   // The dimension 0 index (i/u) is in bit 1 of ij.\n      //   int m = 1 - ((ij >> (1 - d)) & 1);\n      //   child._uv[d][m] = uvMid.get(d);\n      //   child._uv[d][1 - m] = this._uv[d][1 - m];\n      // }\n    }\n    return children;\n  }\n\n  /**\n   * Return the direction vector corresponding to the center in (s,t)-space of\n   * the given cell. This is the point at which the cell is divided into four\n   * subcells; it is not necessarily the centroid of the cell in (u,v)-space or\n   * (x,y,z)-space. The point returned by GetCenterRaw is not necessarily unit\n   * length.\n   */\n  public getCenter():S2Point {\n    return S2Point.normalize(this.getCenterRaw());\n  }\n\n  public getCenterRaw():S2Point {\n    return this.cellID.toPointRaw();\n  }\n\n  /**\n   * Return the center of the cell in (u,v) coordinates (see {@code\n   * S2Projections}). Note that the center of the cell is defined as the point\n   * at which it is recursively subdivided into four children; in general, it is\n   * not at the midpoint of the (u,v) rectangle covered by the cell\n   */\n  public getCenterUV():R2Vector {\n    const i = new MutableInteger(0);\n    const j = new MutableInteger(0);\n    this.cellID.toFaceIJOrientation(i, j, null);\n    let cellSize = 1 << (S2CellId.MAX_LEVEL - this.level);\n\n    // TODO(dbeaumont): Figure out a better naming of the variables here (and elsewhere).\n    let si = (i.val & -cellSize) * 2 + cellSize - S2Cell.MAX_CELL_SIZE;\n    let x = R2Vector.singleStTOUV(S2.toDecimal(1).dividedBy(S2Cell.MAX_CELL_SIZE).times(si))\n    // let x = S2Projections.stToUV((1.0 / S2Cell.MAX_CELL_SIZE) * si);\n\n    let sj = (j.val & -cellSize) * 2 + cellSize - S2Cell.MAX_CELL_SIZE;\n    let y = R2Vector.singleStTOUV(S2.toDecimal(1).dividedBy(S2Cell.MAX_CELL_SIZE).times(sj))\n    // double y = S2Projections.stToUV((1.0 / S2Cell.MAX_CELL_SIZE) * sj);\n\n    return new R2Vector(x, y);\n  }\n\n  /**\n   * Return the average area of cells at this level. This is accurate to within\n   * a factor of 1.7 (for S2_QUADRATIC_PROJECTION) and is extremely cheap to\n   * compute.\n   */\n  public static averageArea(level):number {\n    return S2Projections.AVG_AREA.getValue(level);\n  }\n\n  /**\n   * Return the average area of cells at this level. This is accurate to within\n   * a factor of 1.7 (for S2_QUADRATIC_PROJECTION) and is extremely cheap to\n   * compute.\n   */\n  public averageArea():number {\n    return S2Projections.AVG_AREA.getValue(this.level);\n  }\n\n  /**\n   * Return the approximate area of this cell. This method is accurate to within\n   * 3% percent for all cell sizes and accurate to within 0.1% for cells at\n   * level 5 or higher (i.e. 300km square or smaller). It is moderately cheap to\n   * compute.\n   */\n  public  approxArea():number {\n\n    // All cells at the first two levels have the same area.\n    if (this.level < 2) {\n      return this.averageArea();\n    }\n\n    // First, compute the approximate area of the cell when projected\n    // perpendicular to its normal. The cross product of its diagonals gives\n    // the normal, and the length of the normal is twice the projected area.\n    let flatArea = S2Point.crossProd(\n        S2Point.sub(this.getVertex(2), this.getVertex(0)),\n        S2Point.sub(this.getVertex(3), this.getVertex(1))\n    ).norm().times(0.5);\n    // double flatArea = 0.5 * S2Point.crossProd(\n    //         S2Point.sub(getVertex(2), getVertex(0)), S2Point.sub(getVertex(3), getVertex(1))).norm();\n\n    // Now, compensate for the curvature of the cell surface by pretending\n    // that the cell is shaped like a spherical cap. The ratio of the\n    // area of a spherical cap to the area of its projected disc turns out\n    // to be 2 / (1 + sqrt(1 - r*r)) where \"r\" is the radius of the disc.\n    // For example, when r=0 the ratio is 1, and when r=1 the ratio is 2.\n    // Here we set Pi*r*r == flat_area to find the equivalent disc.\n    return flatArea\n        .times(2)\n        .dividedBy(\n            decimal.Decimal.min(\n                flatArea.times(S2.M_1_PI),\n                1\n            )\n                .neg()\n                .plus(1)\n                .sqrt()\n                .plus(1)\n        ).toNumber();\n  }\n\n//\n// /**\n//  * Return the area of this cell as accurately as possible. This method is more\n//  * expensive but it is accurate to 6 digits of precision even for leaf cells\n//  * (whose area is approximately 1e-18).\n//  */\n  public exactArea():decimal.Decimal {\n    const v0 = this.getVertex(0);\n    const v1 = this.getVertex(1);\n    const v2 = this.getVertex(2);\n    const v3 = this.getVertex(3);\n    return S2.area(v0, v1, v2).plus(S2.area(v0, v2, v3));\n  }\n\n// //////////////////////////////////////////////////////////////////////\n// S2Region interface (see {@code S2Region} for details):\n\n\n  public getCapBound():S2Cap {\n    // Use the cell center in (u,v)-space as the cap axis. This vector is\n    // very close to GetCenter() and faster to compute. Neither one of these\n    // vectors yields the bounding cap with minimal surface area, but they\n    // are both pretty close.\n    //\n    // It's possible to show that the two vertices that are furthest from\n    // the (u,v)-origin never determine the maximum cap size (this is a\n    // possible future optimization).\n    const u = this._uv[0][0].plus(this._uv[0][1]).times(0.5);\n    const v = this._uv[1][0].plus(this._uv[1][1]).times(0.5);\n\n    let cap = new S2Cap(S2Point.normalize(S2Projections.faceUvToXyz(this.face, u, v)), 0);\n    for (let k = 0; k < 4; ++k) {\n      cap = cap.addPoint(this.getVertex(k));\n    }\n    return cap;\n  }\n\n// We grow the bounds slightly to make sure that the bounding rectangle\n// also contains the normalized versions of the vertices. Note that the\n// maximum result magnitude is Pi, with a floating-point exponent of 1.\n// Therefore adding or subtracting 2**-51 will always change the result.\n  private static MAX_ERROR = S2.toDecimal(1.0).dividedBy(S2.toDecimal(new Long(1).shiftLeft(51).toString()));\n\n// The 4 cells around the equator extend to +/-45 degrees latitude at the\n// midpoints of their top and bottom edges. The two cells covering the\n// poles extend down to +/-35.26 degrees at their vertices.\n// adding kMaxError (as opposed to the C version) because of asin and atan2\n// roundoff errors\n  private static POLE_MIN_LAT = decimal.Decimal.asin(S2.toDecimal(1.0).dividedBy(3).sqrt()).minus(S2Cell.MAX_ERROR)\n// 35.26 degrees\n\n\n  public getRectBound():S2LatLngRect {\n    if (this.level > 0) {\n      // Except for cells at level 0, the latitude and longitude extremes are\n      // attained at the vertices. Furthermore, the latitude range is\n      // determined by one pair of diagonally opposite vertices and the\n      // longitude range is determined by the other pair.\n      //\n      // We first determine which corner (i,j) of the cell has the largest\n      // absolute latitude. To maximize latitude, we want to find the point in\n      // the cell that has the largest absolute z-coordinate and the smallest\n      // absolute x- and y-coordinates. To do this we look at each coordinate\n      // (u and v), and determine whether we want to minimize or maximize that\n      // coordinate based on the axis direction and the cell's (u,v) quadrant.\n      const u = this._uv[0][0].plus(this._uv[0][1]);\n      const v = this._uv[1][0].plus(this._uv[1][1]);\n      const i = S2Projections.getUAxis(this.face).z.eq(0) ? (u.lt(0) ? 1 : 0) : (u.gt(0) ? 1 : 0);\n      const j = S2Projections.getVAxis(this.face).z.eq(0) ? (v.lt(0) ? 1 : 0) : (v.gt(0) ? 1 : 0);\n\n      let lat = R1Interval.fromPointPair(this.getLatitude(i, j), this.getLatitude(1 - i, 1 - j));\n      lat = lat.expanded(S2Cell.MAX_ERROR).intersection(S2LatLngRect.fullLat());\n      if (lat.lo.eq(-S2.M_PI_2) || lat.hi .eq(S2.M_PI_2)) {\n        return new S2LatLngRect(lat, S1Interval.full());\n      }\n      let lng = S1Interval.fromPointPair(this.getLongitude(i, 1 - j), this.getLongitude(1 - i, j));\n      return new S2LatLngRect(lat, lng.expanded(S2Cell.MAX_ERROR));\n    }\n\n\n    // The face centers are the +X, +Y, +Z, -X, -Y, -Z axes in that order.\n    // assert (S2Projections.getNorm(face).get(face % 3) == ((face < 3) ? 1 : -1));\n    switch (this.face) {\n      case 0:\n        return new S2LatLngRect(\n            new R1Interval(-S2.M_PI_4, S2.M_PI_4), new S1Interval(-S2.M_PI_4, S2.M_PI_4));\n      case 1:\n        return new S2LatLngRect(\n            new R1Interval(-S2.M_PI_4, S2.M_PI_4), new S1Interval(S2.M_PI_4, 3 * S2.M_PI_4));\n      case 2:\n        return new S2LatLngRect(\n            new R1Interval(S2Cell.POLE_MIN_LAT, S2.M_PI_2), new S1Interval(-S2.M_PI, S2.M_PI));\n      case 3:\n        return new S2LatLngRect(\n            new R1Interval(-S2.M_PI_4, S2.M_PI_4), new S1Interval(3 * S2.M_PI_4, -3 * S2.M_PI_4));\n      case 4:\n        return new S2LatLngRect(\n            new R1Interval(-S2.M_PI_4, S2.M_PI_4), new S1Interval(-3 * S2.M_PI_4, -S2.M_PI_4));\n      default:\n        return new S2LatLngRect(\n            new R1Interval(-S2.M_PI_2, -S2Cell.POLE_MIN_LAT), new S1Interval(-S2.M_PI, S2.M_PI));\n    }\n\n  }\n\n\n  public mayIntersect(cell:S2Cell):boolean {\n    return this.cellID.intersects(cell.cellID);\n  }\n\n  public contains(p:S2Point):boolean {\n    // We can't just call XYZtoFaceUV, because for points that lie on the\n    // boundary between two faces (i.e. u or v is +1/-1) we need to return\n    // true for both adjacent cells.\n\n    const uvPoint = p.toR2Vector(this.face);\n    // S2Projections.faceXyzToUv(this.face, p);\n    if (uvPoint == null) {\n      return false;\n    }\n    return (uvPoint.x.gte(this._uv[0][0]) && uvPoint.x.lte(this._uv[0][1])\n    && uvPoint.y.gte(this._uv[1][0]) && uvPoint.y.lte(this._uv[1][1]));\n  }\n\n// The point 'p' does not need to be normalized.\n\n  public containsC(cell:S2Cell):boolean {\n    return this.cellID.contains(cell.cellID);\n  }\n\n  private init(id:S2CellId) {\n    this.cellID = id;\n    const ij:MutableInteger[] = [];\n    const mOrientation = new MutableInteger(0);\n\n    for (let d = 0; d < 2; ++d) {\n      ij[d] = new MutableInteger(0);\n    }\n\n    this._face = id.toFaceIJOrientation(ij[0], ij[1], mOrientation);\n    this._orientation = mOrientation.val; // Compress int to a byte.\n    this._level = id.level();\n    const cellSize = 1 << (S2CellId.MAX_LEVEL - this.level);\n    for (let d = 0; d < 2; ++d) {\n      // Compute the cell bounds in scaled (i,j) coordinates.\n      const sijLo = (ij[d].val & -cellSize) * 2 - S2Cell.MAX_CELL_SIZE;\n      const sijHi = sijLo + cellSize * 2;\n\n      const s = S2.toDecimal(1).dividedBy(S2Cell.MAX_CELL_SIZE);\n      this._uv[d][0] = R2Vector.singleStTOUV(s.times(sijLo))\n      //S2Projections.stToUV((1.0 / S2Cell.MAX_CELL_SIZE) * sijLo);\n      this._uv[d][1] = R2Vector.singleStTOUV(s.times(sijHi));\n      //S2Projections.stToUV((1.0 / S2Cell.MAX_CELL_SIZE) * sijHi);\n    }\n  }\n\n\n// Internal method that does the actual work in the constructors.\n\n  private getLatitude(i:number, j:number):decimal.Decimal {\n\n    const p = S2Projections.faceUvToXyz(this.face, this._uv[0][i], this._uv[1][j]);\n    return decimal.Decimal.atan2(\n        p.z,\n        p.x.pow(2).plus(p.y.pow(2))\n            .sqrt()\n    );\n    // return Math.atan2(p.z, Math.sqrt(p.x * p.x + p.y * p.y));\n  }\n\n  private getLongitude(i:number, j:number):decimal.Decimal {\n    const p = S2Projections.faceUvToXyz(this.face, this._uv[0][i], this._uv[1][j]);\n    return decimal.Decimal.atan2(\n        p.y,\n        p.x\n    );\n    // Math.atan2(p.y, p.x);\n  }\n\n// Return the latitude or longitude of the cell vertex given by (i,j),\n// where \"i\" and \"j\" are either 0 or 1.\n\n  public  toString():string {\n    return \"[\" + this._face + \", \" + this._level + \", \" + this._orientation + \", \" + this.cellID.toToken() + \"]\";\n  }\n\n  public toGEOJSON() {\n    const coords = [this.getVertex(0),this.getVertex(1),this.getVertex(2),this.getVertex(3),this.getVertex(0)]\n        .map(v => S2LatLng.fromPoint(v))\n        .map(v => ([v.lngDegrees.toNumber(), v.latDegrees.toNumber()]))\n\n    // const rectJSON = this.getRectBound().toGEOJSON();\n    return {\n      type: 'Feature',\n      geometry: {\n        type:'Polygon',\n        coordinates: [coords]\n      },\n      properties: {},\n      title: `Cell: ${this.id.toToken()} lvl: ${this.level}`\n    };\n    // rectJSON.title = `Cell: ${this.id.toToken()}`;\n    // return rectJSON;\n  }\n\n}\n","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Long from 'long';\nimport {S2Region} from \"./S2Region\";\nimport {S2CellId} from \"./S2CellId\";\nimport {S2Cell} from \"./S2Cell\";\nimport {S1Angle} from \"./S1Angle\";\nimport {S2Projections} from \"./S2Projections\";\nimport {S2LatLngRect} from \"./S2LatLngRect\";\nimport {S2Point} from \"./S2Point\";\nimport {S2} from \"./S2\";\nimport {S2Cap} from \"./S2Cap\";\nimport * as decimal from 'decimal.js';\n\n/**\n * An S2CellUnion is a region consisting of cells of various sizes. Typically a\n * cell union is used to approximate some other shape. There is a tradeoff\n * between the accuracy of the approximation and how many cells are used. Unlike\n * polygons, cells have a fixed hierarchical structure. This makes them more\n * suitable for optimizations based on preprocessing.\n *\n */\nexport class S2CellUnion implements S2Region {\n\n\n  /** The CellIds that form the Union */\n  private cellIds:S2CellId[] = [];\n\n  public S2CellUnion() {\n  }\n\n\n  /**\n   * Populates a cell union with the given S2CellIds or 64-bit cells ids, and\n   * then calls Normalize(). The InitSwap() version takes ownership of the\n   * vector data without copying and clears the given vector. These methods may\n   * be called multiple times.\n   */\n  public initFromIds(cellIds:Long[]|string[]) {\n    this.initRawIds(cellIds);\n    this.normalize();\n  }\n\n  public initSwap(cellIds:S2CellId[]) {\n    this.initRawSwap(cellIds);\n    this.normalize();\n  }\n\n  public initRawCellIds(cellIds:S2CellId[]) {\n    this.cellIds = cellIds;\n  }\n\n  public initRawIds(cellIds:Long[]|string[]) {\n    const size = cellIds.length;\n    this.cellIds = [];\n    for (let i = 0; i < size; i++) {\n      this.cellIds.push(new S2CellId(cellIds[i]));\n    }\n  }\n\n  /**\n   * Like Init(), but does not call Normalize(). The cell union *must* be\n   * normalized before doing any calculations with it, so it is the caller's\n   * responsibility to make sure that the input is normalized. This method is\n   * useful when converting cell unions to another representation and back.\n   * These methods may be called multiple times.\n   */\n  public initRawSwap(cellIds:S2CellId[]) {\n    this.cellIds = [].concat(cellIds);\n  }\n\n  public size():number {\n    return this.cellIds.length;\n  }\n\n  /** Convenience methods for accessing the individual cell ids. */\n  public cellId(i:number):S2CellId {\n    return this.cellIds[i];\n  }\n\n  public getCellIds(): S2CellId[] {\n    return this.cellIds;\n  }\n\n\n  /**\n   * Replaces \"output\" with an expanded version of the cell union where any\n   * cells whose level is less than \"min_level\" or where (level - min_level) is\n   * not a multiple of \"level_mod\" are replaced by their children, until either\n   * both of these conditions are satisfied or the maximum level is reached.\n   *\n   *  This method allows a covering generated by S2RegionCoverer using\n   * min_level() or level_mod() constraints to be stored as a normalized cell\n   * union (which allows various geometric computations to be done) and then\n   * converted back to the original list of cell ids that satisfies the desired\n   * constraints.\n   */\n  public denormalize(minLevel:number, levelMod:number):S2CellId[] {\n    // assert (minLevel >= 0 && minLevel <= S2CellId.MAX_LEVEL);\n    // assert (levelMod >= 1 && levelMod <= 3);\n    const output:S2CellId[] = [];\n    for (let i = 0; i < this.cellIds.length; i++) {\n      const id = this.cellIds[i];\n      const level = id.level();\n      let newLevel = Math.max(minLevel, level);\n      if (levelMod > 1) {\n        // Round up so that (new_level - min_level) is a multiple of level_mod.\n        // (Note that S2CellId::kMaxLevel is a multiple of 1, 2, and 3.)\n        newLevel += (S2CellId.MAX_LEVEL - (newLevel - minLevel)) % levelMod;\n        newLevel = Math.min(S2CellId.MAX_LEVEL, newLevel);\n      }\n      if (newLevel == level) {\n        output.push(id);\n      } else {\n        const end = id.childEndL(newLevel);\n        for (let iid = id.childBeginL(newLevel); !iid.equals(end); iid = iid.next()) {\n          output.push(iid);\n        }\n      }\n    }\n    return output;\n  }\n\n  /**\n   * If there are more than \"excess\" elements of the cell_ids() vector that are\n   * allocated but unused, reallocate the array to eliminate the excess space.\n   * This reduces memory usage when many cell unions need to be held in memory\n   * at once.\n   */\n  public pack() {\n    throw new Error('useless');\n    // this.cellIds.trimToSize();\n  }\n  containsC(cell:S2Cell):boolean {\n    return this.containsCell(cell);\n  }\n\n  mayIntersectC(cell:S2Cell):boolean {\n    return this.mayIntersectCell(cell);\n  }\n\n  /**\n   * Return true if the cell union contains the given cell id. Containment is\n   * defined with respect to regions, e.g. a cell contains its 4 children. This\n   * is a fast operation (logarithmic in the size of the cell union).\n   */\n  public contains(id:S2CellId):boolean {\n    // This function requires that Normalize has been called first.\n    //\n    // This is an exact test. Each cell occupies a linear span of the S2\n    // space-filling curve, and the cell id is simply the position at the center\n    // of this span. The cell union ids are sorted in increasing order along\n    // the space-filling curve. So we simply find the pair of cell ids that\n    // surround the given cell id (using binary search). There is containment\n    // if and only if one of these two cell ids contains this cell.\n\n    let pos = S2CellId.binarySearch(this.cellIds, id.id);\n    if (pos < 0) {\n      pos = -pos - 1;\n    }\n    if (pos < this.cellIds.length && this.cellIds[pos].rangeMin().lessOrEquals(id)) {\n      return true;\n    }\n    return pos != 0 && this.cellIds[pos - 1].rangeMax().greaterOrEquals(id);\n  }\n\n  /**\n   * Return true if the cell union intersects the given cell id. This is a fast\n   * operation (logarithmic in the size of the cell union).\n   */\n  public intersects(id:S2CellId):boolean {\n    // This function requires that Normalize has been called first.\n    // This is an exact test; see the comments for Contains() above.\n    let pos = S2CellId.binarySearch(this.cellIds, id.id);\n\n    if (pos < 0) {\n      pos = -pos - 1;\n    }\n\n\n    if (pos < this.cellIds.length && this.cellIds[pos].rangeMin().lessOrEquals(id.rangeMax())) {\n      return true;\n    }\n    return pos != 0 && this.cellIds[pos - 1].rangeMax().greaterOrEquals(id.rangeMin());\n  }\n\n  public containsUnion(that:S2CellUnion):boolean {\n    // A divide-and-conquer or alternating-skip-search approach\n    // may be significantly faster in both the average and worst case.\n    for (let i=0; i<that.cellIds.length;i++) {\n      if (!this.contains(that.cellIds[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** This is a fast operation (logarithmic in the size of the cell union). */\n  public containsCell(cell:S2Cell):boolean {\n    return this.contains(cell.id);\n  }\n\n  /**\n   * Return true if this cell union contain/intersects the given other cell\n   * union.\n   */\n  public intersectsUnion(that:S2CellUnion):boolean {\n    // A divide-and-conquer or alternating-skip-search approach\n    // may be significantly faster in both the average and worst case.\n    for (let i=0; i<that.cellIds.length;i++) {\n      if (!this.intersects(that.cellIds[i])) {\n        return false;\n      }\n    }\n    return true;\n    \n  }\n\n  public getUnion(x:S2CellUnion, y:S2CellUnion) {\n    // assert (x != this && y != this);\n    this.cellIds = [].concat(x.cellIds).concat(y.cellIds);\n    this.normalize();\n  }\n\n  /**\n   * Specialized version of GetIntersection() that gets the intersection of a\n   * cell union with the given cell id. This can be useful for \"splitting\" a\n   * cell union into chunks.\n   */\n  public  getIntersection(x:S2CellUnion, id:S2CellId) {\n    // assert (x != this);\n    this.cellIds = [];\n    if (x.contains(id)) {\n      this.cellIds.push(id);\n    } else {\n      let pos = S2CellId.binarySearch(x.cellIds, id.rangeMin().id);\n\n      if (pos < 0) {\n        pos = -pos - 1;\n      }\n\n      const idmax = id.rangeMax();\n      const size = x.cellIds.length;\n      while (pos < size && x.cellIds[pos].lessOrEquals(idmax)) {\n        this.cellIds.push(x.cellIds[(pos++)]);\n      }\n    }\n  }\n\n  /**\n   * Initialize this cell union to the union or intersection of the two given\n   * cell unions. Requires: x != this and y != this.\n   */\n  public getIntersectionUU(x:S2CellUnion, y:S2CellUnion) {\n    // assert (x != this && y != this);\n\n    // This is a fairly efficient calculation that uses binary search to skip\n    // over sections of both input vectors. It takes constant time if all the\n    // cells of \"x\" come before or after all the cells of \"y\" in S2CellId order.\n\n    this.cellIds = [];\n\n    let i = 0;\n    let j = 0;\n\n    while (i < x.cellIds.length && j < y.cellIds.length) {\n\n      const imin = x.cellId(i).rangeMin();\n      const jmin = y.cellId(j).rangeMin();\n\n      if (imin.greaterThan(jmin)) {\n        // Either j->contains(*i) or the two cells are disjoint.\n        if (x.cellId(i).lessOrEquals(y.cellId(j).rangeMax())) {\n          this.cellIds.push(x.cellId(i++));\n        } else {\n          // Advance \"j\" to the first cell possibly contained by *i.\n          j = S2CellId.indexedBinarySearch(y.cellIds, imin, j + 1);\n          // The previous cell *(j-1) may now contain *i.\n          if (x.cellId(i).lessOrEquals(y.cellId(j - 1).rangeMax())) {\n            --j;\n          }\n        }\n      } else if (jmin.greaterThan(imin)) {\n        // Identical to the code above with \"i\" and \"j\" reversed.\n        if (y.cellId(j).lessOrEquals(x.cellId(i).rangeMax())) {\n          this.cellIds.push(y.cellId(j++));\n        } else {\n          i = S2CellId.indexedBinarySearch(x.cellIds, jmin, i + 1);\n          if (y.cellId(j).lessOrEquals(x.cellId(i - 1).rangeMax())) {\n            --i;\n          }\n        }\n      } else {\n        // \"i\" and \"j\" have the same range_min(), so one contains the other.\n        if (x.cellId(i).lessThan(y.cellId(j))) {\n          this.cellIds.push(x.cellId(i++));\n        } else {\n          this.cellIds.push(y.cellId(j++));\n        }\n      }\n    }\n    // The output is generated in sorted order, and there should not be any\n    // cells that can be merged (provided that both inputs were normalized).\n    // assert (!normalize());\n  }\n\n\n  /**\n   * Expands the cell union such that it contains all cells of the given level\n   * that are adjacent to any cell of the original union. Two cells are defined\n   * as adjacent if their boundaries have any points in common, i.e. most cells\n   * have 8 adjacent cells (not counting the cell itself).\n   *\n   *  Note that the size of the output is exponential in \"level\". For example,\n   * if level == 20 and the input has a cell at level 10, there will be on the\n   * order of 4000 adjacent cells in the output. For most applications the\n   * Expand(min_fraction, min_distance) method below is easier to use.\n   */\n  public expand(level:number) {\n    let output:S2CellId[] = [];\n\n    const levelLsb = S2CellId.lowestOnBitForLevel(level);\n    let i = this.size() - 1;\n    do {\n      let id = this.cellId(i);\n      if (id.lowestOnBit().lessThan(levelLsb)) {\n        id = id.parentL(level);\n        // Optimization: skip over any cells contained by this one. This is\n        // especially important when very small regions are being expanded.\n        while (i > 0 && id.contains(this.cellId(i - 1))) {\n          --i;\n        }\n      }\n      output.push(id);\n      output = output.concat(id.getAllNeighbors(level));\n    } while (--i >= 0);\n    this.initSwap(output);\n  }\n\n  /**\n   * Expand the cell union such that it contains all points whose distance to\n   * the cell union is at most minRadius, but do not use cells that are more\n   * than maxLevelDiff levels higher than the largest cell in the input. The\n   * second parameter controls the tradeoff between accuracy and output size\n   * when a large region is being expanded by a small amount (e.g. expanding\n   * Canada by 1km).\n   *\n   *  For example, if maxLevelDiff == 4, the region will always be expanded by\n   * approximately 1/16 the width of its largest cell. Note that in the worst\n   * case, the number of cells in the output can be up to 4 * (1 + 2 **\n   * maxLevelDiff) times larger than the number of cells in the input.\n   */\n  public expandA(minRadius:S1Angle, maxLevelDiff:number) {\n    let minLevel = S2CellId.MAX_LEVEL;\n    for (let i = 0; i < this.cellIds.length; i++) {\n      const id = this.cellId(i);\n      minLevel = Math.min(minLevel, id.level());\n    }\n    // Find the maximum level such that all cells are at least \"min_radius\"\n    // wide.\n    const radiusLevel = S2Projections.MIN_WIDTH.getMaxLevel(minRadius.radians);\n    if (radiusLevel == 0 && minRadius.radians.gt(S2Projections.MIN_WIDTH.getValue(0))) {\n      // The requested expansion is greater than the width of a face cell.\n      // The easiest way to handle this is to expand twice.\n      this.expand(0);\n    }\n    this.expand(Math.min(minLevel + maxLevelDiff, radiusLevel));\n  }\n\n\npublic  getCapBound():S2Cap {\n  // Compute the approximate centroid of the region. This won't produce the\n  // bounding cap of minimal area, but it should be close enough.\n  if (this.cellIds.length == 0) {\n    return S2Cap.empty();\n  }\n  let centroid = new S2Point(0, 0, 0);\n  this.cellIds.forEach(id => {\n    let area = S2Cell.averageArea(id.level());\n    centroid = S2Point.add(centroid, S2Point.mul(id.toPoint(), area));\n  });\n  \n  if (centroid.equals(new S2Point(0, 0, 0))) {\n    centroid = new S2Point(1, 0, 0);\n  } else {\n    centroid = S2Point.normalize(centroid);\n  }\n\n  // Use the centroid as the cap axis, and expand the cap angle so that it\n  // contains the bounding caps of all the individual cells. Note that it is\n  // *not* sufficient to just bound all the cell vertices because the bounding\n  // cap may be concave (i.e. cover more than one hemisphere).\n  let cap = new S2Cap(centroid, 0);\n  this.cellIds.forEach(id => {\n    cap = cap.addCap(new S2Cell(id).getCapBound());\n  });\n  return cap;\n}\n\n  public getRectBound():S2LatLngRect {\n    let bound = S2LatLngRect.empty();\n    this.cellIds.forEach(id => {\n      bound = bound.union(new S2Cell(id).getRectBound())\n    });\n    return bound;\n  }\n\n\n  /** This is a fast operation (logarithmic in the size of the cell union). */\n  public mayIntersectCell(cell:S2Cell):boolean {\n    return this.intersects(cell.id);\n  }\n\n  /**\n   * The point 'p' does not need to be normalized. This is a fast operation\n   * (logarithmic in the size of the cell union).\n   */\n  public  containsPoint(p:S2Point):boolean {\n    return this.contains(S2CellId.fromPoint(p));\n\n  }\n\n  /**\n   * The number of leaf cells covered by the union.\n   * This will be no more than 6*2^60 for the whole sphere.\n   *\n   * @return the number of leaf cells covered by the union\n   */\n  public leafCellsCovered():Long {\n    let numLeaves = new Long(0);\n    this.cellIds.forEach((id:S2CellId) => {\n      const invertedLevel = S2CellId.MAX_LEVEL - id.level();\n      numLeaves = numLeaves\n          .add(new Long(1).shiftLeft(invertedLevel << 1));\n    });\n    return numLeaves;\n  }\n\n\n  /**\n   * Approximate this cell union's area by summing the average area of\n   * each contained cell's average area, using {@link S2Cell#averageArea()}.\n   * This is equivalent to the number of leaves covered, multiplied by\n   * the average area of a leaf.\n   * Note that {@link S2Cell#averageArea()} does not take into account\n   * distortion of cell, and thus may be off by up to a factor of 1.7.\n   * NOTE: Since this is proportional to LeafCellsCovered(), it is\n   * always better to use the other function if all you care about is\n   * the relative average area between objects.\n   *\n   * @return the sum of the average area of each contained cell's average area\n   */\n  public averageBasedArea():number {\n    return S2.toDecimal(this.leafCellsCovered().toString()).times(S2Projections.AVG_AREA.getValue(S2CellId.MAX_LEVEL)).toNumber();\n  }\n\n  /**\n   * Calculates this cell union's area by summing the approximate area for each\n   * contained cell, using {@link S2Cell#approxArea()}.\n   *\n   * @return approximate area of the cell union\n   */\n  public approxArea():number {\n    let area:decimal.Decimal = S2.toDecimal(0);\n    this.cellIds.forEach(id => {\n      area = area.plus(new S2Cell(id).approxArea());\n    });\n    return area.toNumber();\n  }\n\n  /**\n   * Calculates this cell union's area by summing the exact area for each\n   * contained cell, using the {@link S2Cell#exactArea()}.\n   *\n   * @return the exact area of the cell union\n   */\n  public exactArea():number {\n    let area:decimal.Decimal = S2.toDecimal(0);\n    this.cellIds.forEach(id => {\n      area = area.plus(new S2Cell(id).exactArea());\n    });\n    return area.toNumber();\n  }\n\n\n  /**\n   * Normalizes the cell union by discarding cells that are contained by other\n   * cells, replacing groups of 4 child cells by their parent cell whenever\n   * possible, and sorting all the cell ids in increasing order. Returns true if\n   * the number of cells was reduced.\n   *\n   *  This method *must* be called before doing any calculations on the cell\n   * union, such as Intersects() or Contains().\n   *\n   * @return true if the normalize operation had any effect on the cell union,\n   *         false if the union was already normalized\n   */\n  public normalize():boolean {\n    // Optimize the representation by looking for cases where all subcells\n    // of a parent cell are present.\n    const output:S2CellId[] = [];\n    // ArrayList<S2CellId> output = new ArrayList<>(this.cellIds.size());\n    // output.ensureCapacity(this.cellIds.size());\n\n    this.cellIds.sort((a, b) => a.compareTo(b));\n    // Collections.sort(this.cellIds);\n\n    this.cellIds.forEach(id => {\n      let size = output.length;\n      // Check whether this cell is contained by the previous cell.\n      if (output.length !== 0 && output[size - 1].contains(id)) {\n        return;\n      }\n\n      // Discard any previous cells contained by this cell.\n      while (output.length !== 0 && id.contains(output[output.length - 1])) {\n        output.splice(output.length - 1, 1);\n        // output.remove(output.size() - 1);\n      }\n\n      // Check whether the last 3 elements of \"output\" plus \"id\" can be\n      // collapsed into a single parent cell.\n      while (output.length >= 3) {\n        size = output.length;\n        // A necessary (but not sufficient) condition is that the XOR of the\n        // four cells must be zero. This is also very fast to test.\n        if ((output[size - 3].id.and(output[size - 2].id).and(output[size - 1].id)).notEquals(id.id)) {\n          break;\n        }\n\n        // Now we do a slightly more expensive but exact test. First, compute a\n        // mask that blocks out the two bits that encode the child position of\n        // \"id\" with respect to its parent, then check that the other three\n        // children all agree with \"mask.\n        let mask = id.lowestOnBit().shiftLeft(1) ;\n        mask = mask.add(mask.shiftLeft(1)).not();\n        // mask = ~(mask + (mask << 1));\n        let idMasked = id.id.and(mask);\n        if ((output[size - 3].id.and(mask)).notEquals(idMasked)\n            || (output[size - 2].id.and(mask)).notEquals(idMasked)\n            || (output[size - 1].id.and(mask)).notEquals(idMasked) || id.isFace()) {\n          break;\n        }\n\n        // Replace four children by their parent cell.\n        output.splice(size - 3);\n        // output.remove(size - 1);\n        // output.remove(size - 2);\n        // output.remove(size - 3);\n        id = id.parent();\n      }\n      output.push(id);\n    });\n\n    if (output.length < this.size()) {\n      this.initRawSwap(output);\n      return true;\n    }\n    return false;\n  }\n}\n","/*\n * Copyright 2005 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {S2Cell} from \"./S2Cell\";\nimport {S2Region} from \"./S2Region\";\nimport {S2CellId} from \"./S2CellId\";\nimport {S2CellUnion} from \"./S2CellUnion\";\nimport {S2Projections} from \"./S2Projections\";\nimport {Decimal} from 'decimal.js';\n/**\n * An S2RegionCoverer is a class that allows arbitrary regions to be\n * approximated as unions of cells (S2CellUnion). This is useful for\n * implementing various sorts of search and precomputation operations.\n *\n * Typical usage: {@code S2RegionCoverer coverer; coverer.setMaxCells(5); S2Cap\n * cap = S2Cap.fromAxisAngle(...); S2CellUnion covering;\n * coverer.getCovering(cap, covering); * }\n *\n * This yields a cell union of at most 5 cells that is guaranteed to cover the\n * given cap (a disc-shaped region on the sphere).\n *\n *  The approximation algorithm is not optimal but does a pretty good job in\n * practice. The output does not always use the maximum number of cells allowed,\n * both because this would not always yield a better approximation, and because\n * max_cells() is a limit on how much work is done exploring the possible\n * covering as well as a limit on the final output size.\n *\n *  One can also generate interior coverings, which are sets of cells which are\n * entirely contained within a region. Interior coverings can be empty, even for\n * non-empty regions, if there are no cells that satisfy the provided\n * constraints and are contained by the region. Note that for performance\n * reasons, it is wise to specify a max_level when computing interior coverings\n * - otherwise for regions with small or zero area, the algorithm may spend a\n * lot of time subdividing cells all the way to leaf level to try to find\n * contained cells.\n *\n *  This class is thread-unsafe. Simultaneous calls to any of the getCovering\n * methods will conflict and produce unpredictable results.\n *\n */\nexport class S2RegionCoverer {\n\n  /**\n   * By default, the covering uses at most 8 cells at any level. This gives a\n   * reasonable tradeoff between the number of cells used and the accuracy of\n   * the approximation (see table below).\n   */\n  public static DEFAULT_MAX_CELLS = 8;\n\n  private static FACE_CELLS:S2Cell[] = [0, 1, 2, 3, 4, 5].map(face => S2Cell.fromFacePosLevel(face, 0, 0));\n\n\n  private minLevel:number;\n  private maxLevel:number;\n  private levelMod:number;\n  private maxCells:number;\n\n// True if we're computing an interior covering.\n  private interiorCovering:boolean;\n\n// Counter of number of candidates created, for performance evaluation.\n  private candidatesCreatedCounter:number;\n\n  /**\n   * We save a temporary copy of the pointer passed to GetCovering() in order to\n   * avoid passing this parameter around internally. It is only used (and only\n   * valid) for the duration of a single GetCovering() call.\n   */\n  protected region:S2Region;\n\n  /**\n   * A temporary variable used by GetCovering() that holds the cell ids that\n   * have been added to the covering so far.\n   */\n  protected result:S2CellId[];\n\n\n  /**\n   * We keep the candidates in a priority queue. We specify a vector to hold the\n   * queue entries since for some reason priority_queue<> uses a deque by\n   * default.\n   */\n  private candidateQueue:PriorityQueue<QueueEntry>;\n\n  /**\n   * Default constructor, sets all fields to default values.\n   */\n  public constructor() {\n    this.minLevel = 0;\n    this.maxLevel = S2CellId.MAX_LEVEL;\n    this.levelMod = 1;\n    this.maxCells = S2RegionCoverer.DEFAULT_MAX_CELLS;\n    this.region = null;\n    this.result = [];\n    this.candidateQueue = new PriorityQueue<QueueEntry>();\n  }\n\n// Set the minimum and maximum cell level to be used. The default is to use\n// all cell levels. Requires: max_level() >= min_level().\n//\n// To find the cell level corresponding to a given physical distance, use\n// the S2Cell metrics defined in s2.h. For example, to find the cell\n// level that corresponds to an average edge length of 10km, use:\n//\n// int level = S2::kAvgEdge.GetClosestLevel(\n// geostore::S2Earth::KmToRadians(length_km));\n//\n// Note: min_level() takes priority over max_cells(), i.e. cells below the\n// given level will never be used even if this causes a large number of\n// cells to be returned.\n\n  /**\n   * Sets the minimum level to be used.\n   */\n  public setMinLevel(minLevel:number):S2RegionCoverer {\n    // assert (minLevel >= 0 && minLevel <= S2CellId.MAX_LEVEL);\n    this.minLevel = Math.max(0, Math.min(S2CellId.MAX_LEVEL, minLevel));\n    return this;\n  }\n\n  /**\n   * Sets the maximum level to be used.\n   */\n  public setMaxLevel(maxLevel:number):S2RegionCoverer {\n    // assert (maxLevel >= 0 && maxLevel <= S2CellId.MAX_LEVEL);\n    this.maxLevel = Math.max(0, Math.min(S2CellId.MAX_LEVEL, maxLevel));\n    return this;\n  }\n\n  /**\n   * If specified, then only cells where (level - min_level) is a multiple of\n   * \"level_mod\" will be used (default 1). This effectively allows the branching\n   * factor of the S2CellId hierarchy to be increased. Currently the only\n   * parameter values allowed are 1, 2, or 3, corresponding to branching factors\n   * of 4, 16, and 64 respectively.\n   */\n  public setLevelMod(levelMod:number):S2RegionCoverer {\n    // assert (levelMod >= 1 && levelMod <= 3);\n    this.levelMod = Math.max(1, Math.min(3, levelMod));\n    return this;\n  }\n\n  /**\n   * Sets the maximum desired number of cells in the approximation (defaults to\n   * kDefaultMaxCells). Note the following:\n   *\n   * <ul>\n   * <li>For any setting of max_cells(), up to 6 cells may be returned if that\n   * is the minimum number of cells required (e.g. if the region intersects all\n   * six face cells). Up to 3 cells may be returned even for very tiny convex\n   * regions if they happen to be located at the intersection of three cube\n   * faces.\n   *\n   * <li>For any setting of max_cells(), an arbitrary number of cells may be\n   * returned if min_level() is too high for the region being approximated.\n   *\n   * <li>If max_cells() is less than 4, the area of the covering may be\n   * arbitrarily large compared to the area of the original region even if the\n   * region is convex (e.g. an S2Cap or S2LatLngRect).\n   * </ul>\n   *\n   * Accuracy is measured by dividing the area of the covering by the area of\n   * the original region. The following table shows the median and worst case\n   * values for this area ratio on a test case consisting of 100,000 spherical\n   * caps of random size (generated using s2regioncoverer_unittest):\n   *\n   * <pre>\n   * max_cells: 3 4 5 6 8 12 20 100 1000\n   * median ratio: 5.33 3.32 2.73 2.34 1.98 1.66 1.42 1.11 1.01\n   * worst case: 215518 14.41 9.72 5.26 3.91 2.75 1.92 1.20 1.02\n   * </pre>\n   */\n  public setMaxCells(maxCells:number):S2RegionCoverer {\n    this.maxCells = maxCells;\n    return this;\n  }\n\n  /**\n   * Computes a list of cell ids that covers the given region and satisfies the\n   * various restrictions specified above.\n   *\n   * @param region The region to cover\n   * @param covering The list filled in by this method\n   */\n  public getCoveringCells(region:S2Region):S2CellId[] {\n    // Rather than just returning the raw list of cell ids generated by\n    // GetCoveringInternal(), we construct a cell union and then denormalize it.\n    // This has the effect of replacing four child cells with their parent\n    // whenever this does not violate the covering parameters specified\n    // (min_level, level_mod, etc). This strategy significantly reduces the\n    // number of cells returned in many cases, and it is cheap compared to\n    // computing the covering in the first place.\n    const tmp = this.getCoveringUnion(region);\n    return tmp.denormalize(this.minLevel, this.levelMod);\n  }\n\n  /**\n   * Computes a list of cell ids that is contained within the given region and\n   * satisfies the various restrictions specified above.\n   *\n   * @param region The region to fill\n   * @param interior The list filled in by this method\n   */\n  public getInteriorCoveringCells(region:S2Region):S2CellId[] {\n    const tmp = this.getInteriorCoveringUnion(region);\n    return tmp.denormalize(this.minLevel, this.levelMod);\n  }\n\n  /**\n   * Return a normalized cell union that covers the given region and satisfies\n   * the restrictions *EXCEPT* for min_level() and level_mod(). These criteria\n   * cannot be satisfied using a cell union because cell unions are\n   * automatically normalized by replacing four child cells with their parent\n   * whenever possible. (Note that the list of cell ids passed to the cell union\n   * constructor does in fact satisfy all the given restrictions.)\n   */\n  public getCoveringUnion(region:S2Region, covering:S2CellUnion = new S2CellUnion()):S2CellUnion {\n    this.interiorCovering = false;\n    this.getCoveringInternal(region);\n    covering.initSwap(this.result);\n    return covering;\n  }\n\n  /**\n   * Return a normalized cell union that is contained within the given region\n   * and satisfies the restrictions *EXCEPT* for min_level() and level_mod().\n   */\n  public getInteriorCoveringUnion(region:S2Region, covering:S2CellUnion=new S2CellUnion()):S2CellUnion {\n    this.interiorCovering = true;\n    this.getCoveringInternal(region);\n    covering.initSwap(this.result);\n    return covering;\n  }\n\n// /**\n//  * Given a connected region and a starting point, return a set of cells at the\n//  * given level that cover the region.\n//  */\n// public static getSimpleCovering(\n//     region:S2Region , start:S2Point , level:number):S2CellId[] {\n//   S2RegionCoverer.floodFill(region, S2CellId.fromPoint(start).parentL(level));\n// }\n\n  /**\n   * If the cell intersects the given region, return a new candidate with no\n   * children, otherwise return null. Also marks the candidate as \"terminal\" if\n   * it should not be expanded further.\n   */\n  private newCandidate(cell:S2Cell):Candidate {\n    if (!this.region.mayIntersectC(cell)) {\n      // console.log(\"NOT INTERSECTING\",this.region);\n      return null;\n    }\n\n    let isTerminal = false;\n    if (cell.level >= this.minLevel) {\n      if (this.interiorCovering) {\n        if (this.region.containsC(cell)) {\n          isTerminal = true;\n        } else if (cell.level + this.levelMod > this.maxLevel) {\n          return null;\n        }\n      } else {\n        if (cell.level + this.levelMod > this.maxLevel || this.region.containsC(cell)) {\n          isTerminal = true;\n        }\n      }\n    }\n\n    const candidate = new Candidate();\n    candidate.cell = cell;\n    candidate.isTerminal = isTerminal;\n    candidate.numChildren = 0;\n    if (!isTerminal) {\n      candidate.children = Array.apply(null, new Array(1<<this.maxChildrenShift()));\n      // protonew Candidate[1 << this.maxChildrenShift()];\n    }\n    this.candidatesCreatedCounter++;\n    return candidate;\n  }\n\n  /** Return the log base 2 of the maximum number of children of a candidate. */\n  private maxChildrenShift():number {\n    return 2 * this.levelMod;\n  }\n\n  /**\n   * Process a candidate by either adding it to the result list or expanding its\n   * children and inserting it into the priority queue. Passing an argument of\n   * NULL does nothing.\n   */\n  private addCandidate(candidate:Candidate) {\n\n    if (candidate == null) {\n      return;\n    }\n\n    if (candidate.isTerminal) {\n      this.result.push(candidate.cell.id);\n      return;\n    }\n    // assert (candidate.numChildren == 0);\n\n    // Expand one level at a time until we hit min_level_ to ensure that\n    // we don't skip over it.\n    const numLevels = (candidate.cell.level < this.minLevel) ? 1 : this.levelMod;\n\n    const numTerminals = this.expandChildren(candidate, candidate.cell, numLevels);\n\n    if (candidate.numChildren == 0) {\n      // Do nothing\n    } else if (!this.interiorCovering && numTerminals == 1 << this.maxChildrenShift()\n        && candidate.cell.level >= this.minLevel) {\n      // Optimization: add the parent cell rather than all of its children.\n      // We can't do this for interior coverings, since the children just\n      // intersect the region, but may not be contained by it - we need to\n      // subdivide them further.\n      candidate.isTerminal = true;\n      this.addCandidate(candidate);\n\n    } else {\n      // We negate the priority so that smaller absolute priorities are returned\n      // first. The heuristic is designed to refine the largest cells first,\n      // since those are where we have the largest potential gain. Among cells\n      // at the same level, we prefer the cells with the smallest number of\n      // intersecting children. Finally, we prefer cells that have the smallest\n      // number of children that cannot be refined any further.\n      const priority = -((((candidate.cell.level << this.maxChildrenShift()) + candidate.numChildren)\n      << this.maxChildrenShift()) + numTerminals);\n\n      this.candidateQueue.add(new QueueEntry(priority, candidate));\n      // logger.info(\"Push: \" + candidate.cell.id() + \" (\" + priority + \") \");\n    }\n  }\n\n  /**\n   * Populate the children of \"candidate\" by expanding the given number of\n   * levels from the given cell. Returns the number of children that were marked\n   * \"terminal\".\n   */\n  private expandChildren(candidate:Candidate, cell:S2Cell, numLevels:number):number {\n    numLevels--;\n\n\n    const childCells = cell.subdivide();\n\n\n    let numTerminals = 0;\n    for (let i = 0; i < 4; ++i) {\n      if (numLevels > 0) {\n        if (this.region.mayIntersectC(childCells[i])) {\n          numTerminals += this.expandChildren(candidate, childCells[i], numLevels);\n        }\n        continue;\n      }\n      let child = this.newCandidate(childCells[i]);\n\n      if (child != null) {\n        candidate.children[candidate.numChildren++] = child;\n        if (child.isTerminal) {\n          ++numTerminals;\n        }\n      }\n    }\n\n\n    return numTerminals;\n  }\n\n  /** Computes a set of initial candidates that cover the given region. */\n  private getInitialCandidates() {\n    // Optimization: if at least 4 cells are desired (the normal case),\n    // start with a 4-cell covering of the region's bounding cap. This\n    // lets us skip quite a few levels of refinement when the region to\n    // be covered is relatively small.\n    if (this.maxCells >= 4) {\n      // Find the maximum level such that the bounding cap contains at most one\n      // cell vertex at that level.\n      const cap = this.region.getCapBound();\n      let level = Decimal.min(\n          S2Projections.MIN_WIDTH.getMaxLevel(cap.angle().radians.times(2)),\n          Decimal.min(this.maxLevel, S2CellId.MAX_LEVEL - 1)\n      ).toNumber();\n      if (this.levelMod > 1 && level > this.minLevel) {\n        level -= (level - this.minLevel) % this.levelMod;\n      }\n      // We don't bother trying to optimize the level == 0 case, since more than\n      // four face cells may be required.\n      if (level > 0) {\n        // Find the leaf cell containing the cap axis, and determine which\n        // subcell of the parent cell contains it.\n        // ArrayList<S2CellId> base = new ArrayList<>(4);\n        const id = S2CellId.fromPoint(cap.axis);\n        const base = id.getVertexNeighbors(level);\n        for (let i = 0; i < base.length; ++i) {\n          this.addCandidate(this.newCandidate(new S2Cell(base[i])));\n        }\n        return;\n      }\n    }\n    // Default: start with all six cube faces.\n    for (let face = 0; face < 6; ++face) {\n      this.addCandidate(this.newCandidate(S2RegionCoverer.FACE_CELLS[face]));\n    }\n  }\n\n  /** Generates a covering and stores it in result. */\n  private getCoveringInternal(region:S2Region) {\n    // Strategy: Start with the 6 faces of the cube. Discard any\n    // that do not intersect the shape. Then repeatedly choose the\n    // largest cell that intersects the shape and subdivide it.\n    //\n    // result contains the cells that will be part of the output, while the\n    // priority queue contains cells that we may still subdivide further. Cells\n    // that are entirely contained within the region are immediately added to\n    // the output, while cells that do not intersect the region are immediately\n    // discarded.\n    // Therefore pq_ only contains cells that partially intersect the region.\n    // Candidates are prioritized first according to cell size (larger cells\n    // first), then by the number of intersecting children they have (fewest\n    // children first), and then by the number of fully contained children\n    // (fewest children first).\n\n    if (!(this.candidateQueue.size() == 0 && this.result.length == 0)) {\n      throw new Error('preconditions are not satisfied')\n    }\n    // Preconditions.checkState(this.candidateQueue.isEmpty() && this.result.isEmpty());\n\n    this.region = region;\n    this.candidatesCreatedCounter = 0;\n\n    this.getInitialCandidates();\n    \n    while (this.candidateQueue.size() !== 0 && (!this.interiorCovering || this.result.length < this.maxCells)) {\n      const candidate = this.candidateQueue.poll().candidate;\n      // logger.info(\"Pop: \" + candidate.cell.id());\n      if (candidate.cell.level < this.minLevel || candidate.numChildren == 1\n          || this.result.length + (this.interiorCovering ? 0 : this.candidateQueue.size()) + candidate.numChildren\n          <= this.maxCells) {\n        // Expand this candidate into its children.\n        for (let i = 0; i < candidate.numChildren; ++i) {\n          this.addCandidate(candidate.children[i]);\n        }\n      } else if (this.interiorCovering) {\n        // Do nothing\n      } else {\n        candidate.isTerminal = true;\n        this.addCandidate(candidate);\n      }\n    }\n\n    this.candidateQueue.clear();\n    this.region = null;\n  }\n\n//\n//   /**\n//    * Given a region and a starting cell, return the set of all the\n//    * edge-connected cells at the same level that intersect \"region\". The output\n//    * cells are returned in arbitrary order.\n//    */\n//   private static void floodFill(S2Region region, S2CellId start, ArrayList<S2CellId> output) {\n//   HashSet<S2CellId> all = new HashSet<>();\n//   ArrayList<S2CellId> frontier = new ArrayList<>();\n//   output.clear();\n//   all.add(start);\n//   frontier.add(start);\n//   while (!frontier.isEmpty()) {\n//   S2CellId id = frontier.get(frontier.size() - 1);\n//   frontier.remove(frontier.size() - 1);\n//   if (!region.mayIntersect(new S2Cell(id))) {\n//   continue;\n// }\n// output.add(id);\n//\n// S2CellId[] neighbors = new S2CellId[4];\n// id.getEdgeNeighbors(neighbors);\n// for (int edge = 0; edge < 4; ++edge) {\n//   S2CellId nbr = neighbors[edge];\n//   boolean hasNbr = all.contains(nbr);\n//   if (!all.contains(nbr)) {\n//     frontier.add(nbr);\n//     all.add(nbr);\n//   }\n// }\n// }\n// }\n}\n\n\nclass Candidate {\n  public cell:S2Cell;\n  public isTerminal:boolean; // Cell should not be expanded further.\n  public numChildren:number; // Number of children that intersect the region.\n  public children:Candidate[]; // Actual size may be 0, 4, 16, or 64\n  // elements.\n  \n  public toString() {\n    return `isTermina: ${this.isTerminal} - Cell: ${this.cell.toString()}`;\n  }\n}\n\ninterface Comparable<T> {\n  compare(other:T):number;\n}\nclass PriorityQueue<T extends Comparable<T>> {\n  public items:T[];\n\n  constructor() {\n    this.clear();\n  }\n\n  add(item:T) {\n    this.items.push(item);\n    this.items.sort((a, b) => a.compare(b));\n  }\n\n  clear() {\n    this.items = [];\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  poll():T {\n    return this.items.splice(0, 1)[0];\n  }\n}\n\nclass QueueEntry implements Comparable<QueueEntry> {\n  compare(other:QueueEntry):number {\n    return this.id < other.id ? 1 : (this.id > other.id ? -1 : 0);\n  }\n\n  public constructor(public id:number, public candidate:Candidate) {\n\n  }\n}\n","import {S2Region} from \"./S2Region\";\nimport {S2LatLng} from \"./S2LatLng\";\nimport {S2Cap} from \"./S2Cap\";\nexport * from './Interval';\nexport * from './MutableInteger';\nexport * from './R1Interval';\nexport * from './R2Vector';\nexport * from './S1Angle';\nexport * from './S1Interval';\nexport * from './S2';\nexport * from './S2Cap';\nexport * from './S2Cell';\nexport * from './S2CellId';\nexport * from './S2CellUnion';\n// export * from './S2EdgeIndex';\n// export * from './S2EdgeUtil';\nexport * from './S2LatLng';\nexport * from './S2LatLngRect';\n// export * from './S2Loop';\nexport * from './S2Point';\nexport * from './S2Projections';\nexport * from './S2Region';\nexport * from './S2RegionCoverer';\n\nexport class Utils {\n\n  /**\n   * Calculates a region covering a circle\n   * NOTE: The current implementation uses S2Cap while S2Loop would be better (S2Loop is not implemented yet)\n   * @param center\n   * @param radiusInKM\n   * @param points the number of points to calculate. The higher the better precision\n   * @returns {S2Region}\n   */\n  static calcRegionFromCenterRadius(center:S2LatLng, radiusInKM:number, points:number=16):S2Region {\n    const pointsAtDistance = center.pointsAtDistance(radiusInKM, points);\n    let s2Cap = S2Cap.empty().addPoint(center.toPoint());\n    // It would be probably enough to add one of the points/2 pair of opposite points in the circle such\n    // as (0, points/2). but since this is just a temporary solution lets stick with this as it\n    // will come handy when implementing S2Loop.\n    pointsAtDistance\n        .map(p => p.toPoint())\n        .forEach(p => {\n          s2Cap = s2Cap.addPoint(p);\n        });\n    return s2Cap;\n  }\n}\n"],"names":["decimal.Decimal","S2Metric","tslib_1.__extends","Decimal","Projections"],"mappings":"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"}